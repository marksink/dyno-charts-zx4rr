<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ZX-4RR Dyno App</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  
  <!-- Settings Panel -->
  <div id="settingsPanel" class="settings-panel" onclick="closeSettings(event)">
    <div class="settings-content" onclick="event.stopPropagation()">
      <div class="settings-header">
        <div class="settings-title">Unit Preferences</div>
        <div class="settings-close" onclick="closeSettings()">&times;</div>
      </div>
      
      <div class="settings-group">
        <label for="powerUnit">Power Unit:</label>
        <select id="powerUnit" onchange="updateUnitPreferences()">
          <option value="HP">HP (Horsepower)</option>
          <option value="BHP">BHP (Brake Horsepower)</option>
          <option value="PS">PS (Pferdestärke)</option>
          <option value="kW">kW (Kilowatts)</option>
        </select>
      </div>
      
      <div class="settings-group">
        <label for="torqueUnit">Torque Unit:</label>
        <select id="torqueUnit" onchange="updateUnitPreferences()">
          <option value="lb-ft">lb-ft (pound-feet)</option>
          <option value="Nm">N⋅m (Newton-meters)</option>
          <option value="kgfm">kgf⋅m (kilogram-force meters)</option>
        </select>
      </div>
      
      <div class="settings-group">
        <label for="speedUnit">Speed Unit:</label>
        <select id="speedUnit" onchange="updateUnitPreferences()">
          <option value="MPH">MPH (miles per hour)</option>
          <option value="kmh">km/h (kilometers per hour)</option>
        </select>
      </div>
      
      <div class="settings-buttons">
        <button class="settings-btn secondary" onclick="resetUnitsToDefault()">Reset to Default</button>
        <button class="settings-btn" onclick="closeSettings()">Done</button>
      </div>
    </div>
  </div>

  <h1 id="bikeTitle" style="text-align:center;">Loading...</h1>
  <div class="controls">
    <div class="control-group">
      <div class="settings-icon" onclick="openSettings()" title="Units Settings">⚙️</div>
    </div>

    <div class="control-group">
      <label for="bikeSelect">Bike:</label>
      <select id="bikeSelect" onchange="changeBike()">
        <option value="">Loading bikes...</option>
      </select>
    </div>

    <div class="control-group">
      <label for="front">F-Sprocket:</label>
      <input id="front" type="number" value="14" step="1" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <label for="rear">R-Sprocket:</label>
      <input id="rear" type="number" value="48" step="1" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <label for="hpData">ECU Tune:</label>
      <select id="hpData" onchange="plotTorque(true)"></select>
    </div>

    <div class="control-group">
      <label for="viewSelect">Plot:</label>
      <select id="viewSelect" onchange="plotTorque(true)">
        <option value="wheel" selected>Wheel TQ / Shift</option>
        <option value="dyno">Power Curves</option>
        <option value="accel_ts">Time vs Speed</option>
        <option value="accel_td">Time vs Distance</option>
        <option value="accel_tg">Time vs G's</option>
        <option value="accel_sg">Speed vs G's</option>
      </select>
    </div>

    <div class="control-group">
      <label for="shiftRpmSelect">Shift RPM:</label>
      <div class="custom-shift-dropdown">
        <select id="shiftRpmSelect" onchange="handleShiftRpmChange()" style="display: none;">
          <option value="optimal">Optimal</option>
          <option value="custom">Custom</option>
        </select>
        <div class="shift-rpm-display" onclick="toggleShiftRpmDropdown()">
          <span id="shiftRpmDisplayText">Optimal</span>
          <span class="dropdown-arrow">▼</span>
        </div>
        <div id="shiftRpmOptions" class="shift-rpm-options" style="display: none;">
          <div class="shift-option" onclick="selectShiftRpm('optimal')">Optimal</div>
          <div class="shift-option custom-input">
            <input type="number" id="customShiftRpm" placeholder="Enter RPM" min="3400" max="16000" step="100" onkeypress="handleCustomRpmKeypress(event)" onblur="handleCustomRpmBlur()">
          </div>
        </div>
      </div>
    </div>

    <!-- Accel-only controls -->
    <div class="control-group">
      <label id="weightLbLabel" for="weightLb">Weight (lb):</label>
      <input id="weightLb" type="number" value="580" min="300" max="1000" step="1" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <label id="shiftMsLabel" for="shiftMs">Shift Time (ms):</label>
      <input id="shiftMs" type="number" value="80" min="0" max="300" step="10" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <input type="checkbox" id="truncateCross" onchange="plotTorque(false)">
      <label for="truncateCross">Clip Curves</label>
    </div>
  </div>
  
  <div class="button-row">
    <button onclick="freezeCurrentTraces()">Compare</button>
    <button onclick="clearFrozenTraces()">Reset</button>
  </div>

  <div id="plot" style="position: relative;">
    <div id="freezeNotification" style="
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(255,255,255,0.9); color: #111; padding: 8px 12px;
        border-radius: 4px; font-weight: bold; display: none; z-index: 1000;">
      Select New Options!
    </div>
  </div>

<script>
// -------- Unit Conversion System --------
const UnitConverter = {
  // Conversion factors to base units (HP for power, lb-ft for torque, MPH for speed)
  power: {
    'HP': 1.0,
    'BHP': 1.0, // BHP ≈ HP
    'PS': 1.0 / 0.98592, // 1 PS = 0.98592 HP
    'kW': 1.0 / 0.746  // 1 HP = 0.746 kW
  },
  torque: {
    'lb-ft': 1.0,
    'Nm': 1.0 / 1.356, // 1 lb-ft = 1.356 N⋅m
    'kgfm': 1.0 / 9.807 // 1 kgf⋅m = 9.807 N⋅m
  },
  speed: {
    'MPH': 1.0,
    'kmh': 1.0 / 1.609 // 1 MPH = 1.609 km/h
  },
  distance: {
    'ft': 1.0,
    'm': 1.0 / 3.28084 // 1 ft = 0.3048 m
  },
  weight: {
    'lb': 1.0,
    'kg': 1.0 / 2.20462 // 1 lb = 0.453592 kg
  },
  
  // Convert from base unit to target unit
  convertPower: function(value, targetUnit) {
    return value / this.power[targetUnit];
  },
  
  convertTorque: function(value, targetUnit) {
    return value / this.torque[targetUnit];
  },
  
  convertSpeed: function(value, targetUnit) {
    return value / this.speed[targetUnit];
  },
  
  convertDistance: function(value, targetUnit) {
    return value / this.distance[targetUnit];
  },
  
  convertWeight: function(value, targetUnit) {
    return value * this.weight[targetUnit];
  },
  
  // Format values with appropriate precision and unit symbol
  formatPower: function(value, unit) {
    const converted = this.convertPower(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatTorque: function(value, unit) {
    const converted = this.convertTorque(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatSpeed: function(value, unit) {
    const converted = this.convertSpeed(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatDistance: function(value, unit) {
    const converted = this.convertDistance(value, unit);
    return `${converted.toFixed(0)} ${unit}`;
  },
  
  formatWeight: function(value, unit) {
    const converted = this.convertWeight(value, unit);
    return `${converted.toFixed(0)} ${unit}`;
  },
  
  // Get proper unit labels for axes
  getPowerLabel: function(unit) {
    const labels = {
      'HP': 'Horsepower (HP)',
      'BHP': 'Brake Horsepower (BHP)', 
      'PS': 'Pferdestärke (PS)',
      'kW': 'Kilowatts (kW)'
    };
    return labels[unit] || 'Power';
  },
  
  getTorqueLabel: function(unit) {
    const labels = {
      'lb-ft': 'Torque (lb-ft)',
      'Nm': 'Torque (N⋅m)',
      'kgfm': 'Torque (kgf⋅m)'
    };
    return labels[unit] || 'Torque';
  },
  
  getSpeedLabel: function(unit) {
    const labels = {
      'MPH': 'Speed (MPH)',
      'kmh': 'Speed (km/h)'
    };
    return labels[unit] || 'Speed';
  },
  
  getDistanceLabel: function(unit) {
    const labels = {
      'ft': 'Distance (ft)',
      'm': 'Distance (m)'
    };
    return labels[unit] || 'Distance';
  },
  
  // Get the appropriate distance unit based on speed unit
  getDistanceUnit: function(speedUnit) {
    return speedUnit === 'kmh' ? 'm' : 'ft';
  },
  
  getWeightLabel: function(unit) {
    const labels = {
      'lb': 'Weight (lb)',
      'kg': 'Weight (kg)'
    };
    return labels[unit] || 'Weight';
  },
  
  // Get the appropriate weight unit based on speed unit
  getWeightUnit: function(speedUnit) {
    return speedUnit === 'kmh' ? 'kg' : 'lb';
  }
};

// -------- User Preferences --------
let userPreferences = {
  power: 'HP',
  torque: 'lb-ft',
  speed: 'MPH'
};

// Load preferences from localStorage
function loadUnitPreferences() {
  try {
    const saved = localStorage.getItem('dynoChartUnitPrefs');
    if (saved) {
      const prefs = JSON.parse(saved);
      userPreferences = { ...userPreferences, ...prefs };
    }
  } catch (e) {
    console.warn('Failed to load unit preferences:', e);
  }
  
  // Update UI selectors
  document.getElementById('powerUnit').value = userPreferences.power;
  document.getElementById('torqueUnit').value = userPreferences.torque;
  document.getElementById('speedUnit').value = userPreferences.speed;
  
  // Update weight control to match speed units
  updateWeightControl();
}

// Save preferences to localStorage
function saveUnitPreferences() {
  try {
    localStorage.setItem('dynoChartUnitPrefs', JSON.stringify(userPreferences));
  } catch (e) {
    console.warn('Failed to save unit preferences:', e);
  }
}

// Update preferences from UI
function updateUnitPreferences() {
  userPreferences.power = document.getElementById('powerUnit').value;
  userPreferences.torque = document.getElementById('torqueUnit').value;
  userPreferences.speed = document.getElementById('speedUnit').value;
  
  saveUnitPreferences();
  updateWeightControl(); // Update weight control units
  plotTorque(false); // Re-render with new units
}

// Track the base weight in pounds to avoid conversion errors
let baseWeightLb = 580;

// Update weight control based on speed unit preference
function updateWeightControl() {
  const newWeightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  const oldWeightUnit = UnitConverter.getWeightUnit(userPreferences.speed === 'kmh' ? 'MPH' : 'kmh'); // Get opposite unit
  const weightLabel = document.getElementById('weightLbLabel');
  const weightInput = document.getElementById('weightLb');
  
  if (weightLabel && weightInput) {
    // Only update if the unit actually changed
    const currentLabel = weightLabel.textContent;
    const expectedLabel = UnitConverter.getWeightLabel(newWeightUnit) + ':';
    
    if (currentLabel !== expectedLabel) {
      // Convert from base weight in pounds
      const convertedValue = UnitConverter.convertWeight(baseWeightLb, newWeightUnit);
      
      // Update label and value
      weightLabel.textContent = expectedLabel;
      weightInput.value = Math.round(convertedValue);
    }
  }
}

// Reset to defaults
function resetUnitsToDefault() {
  userPreferences = {
    power: 'HP',
    torque: 'lb-ft',
    speed: 'MPH'
  };
  
  document.getElementById('powerUnit').value = userPreferences.power;
  document.getElementById('torqueUnit').value = userPreferences.torque;
  document.getElementById('speedUnit').value = userPreferences.speed;
  
  // Reset weight to default 580 lb equivalent in preferred units
  baseWeightLb = 580;
  const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  const weightInput = document.getElementById('weightLb');
  const weightLabel = document.getElementById('weightLbLabel');
  
  if (weightInput && weightLabel) {
    const convertedWeight = UnitConverter.convertWeight(baseWeightLb, weightUnit);
    weightInput.value = Math.round(convertedWeight);
    weightLabel.textContent = UnitConverter.getWeightLabel(weightUnit) + ':';
  }
  
  saveUnitPreferences();
  plotTorque(false);
}

// Settings panel functions
function openSettings() {
  document.getElementById('settingsPanel').style.display = 'block';
}

function closeSettings(event) {
  if (!event || event.target.id === 'settingsPanel' || event.target.classList.contains('settings-close')) {
    document.getElementById('settingsPanel').style.display = 'none';
  }
}

// -------- Constants & data --------
// These will be loaded from bike data files
let primary_drive = 2.029;
let tire_circ_in = 77.15;
let gear_ratios = {1:2.92, 2:2.05, 3:1.62, 4:1.33, 5:1.15, 6:1.03};
let Crr = 0.015;
let CdA = 0.35;
let hp_data_sets = {};
let currentBikeData = null;

// Accel sim - now handles different weight units
function getMassLb() {
  const el = document.getElementById('weightLb');
  const v = el ? parseFloat(el.value) : 580;
  const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  
  if (Number.isFinite(v) && v > 0) {
    // Update base weight when user changes input
    baseWeightLb = weightUnit === 'kg' ? v * 2.20462 : v;
    return baseWeightLb;
  }
  return 580; // Default in lb
}
function getShiftMs() {
  const el = document.getElementById('shiftMs');
  const v = el ? parseFloat(el.value) : 80;
  return Number.isFinite(v) && v >= 0 ? v : 80;
}

// Crr and CdA now loaded from bike data
const rho_air = 1.225;
const g_mps2 = 9.80665;
const LB_TO_KG = 0.45359237;
const LBF_FT_TO_NM = 1.3558179483;
const IN_TO_M = 0.0254;
const MPH_TO_MPS = 0.44704;
const MPS_TO_MPH = 2.236936;
const M_TO_FT = 3.28084;

// Vertical label placement for Accel compare markers
const ACCEL_LABEL_BASE = 0.97;
const ACCEL_LABEL_STEP = 0.03;
const ACCEL_SPEED_YMAX = 150;  // mph axis cap for accel_ts


const wheel_radius_m = (tire_circ_in * IN_TO_M) / (2 * Math.PI);

function speedToRpm(speed_mph, gear_ratio, final_drive) {
  return speed_mph * (primary_drive * gear_ratio * final_drive * 1056) / tire_circ_in;
}
function rpmToSpeed(rpm, gear_ratio, final_drive) {
  return rpm * tire_circ_in / (primary_drive * gear_ratio * final_drive * 1056);
}
function hpToWheelTorqueAt(rpmArr, hpArr, gear_ratio, final_drive) {
  const overall = primary_drive * gear_ratio * final_drive;
  return rpmArr.map((rpm, i) => (hpArr[i] * 5252 / rpm) * overall);
}
function lerp(x1, y1, x2, y2, y) { return x1 + (y - y1) * (x2 - x1) / (y2 - y1); }
function interp1(xArr, yArr, x) {
  if (x <= xArr[0]) return yArr[0];
  if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
  let lo = 0, hi = xArr.length - 1;
  while (hi - lo > 1) { const mid = (lo + hi) >> 1; if (xArr[mid] <= x) lo = mid; else hi = mid; }
  const x1 = xArr[lo], x2 = xArr[hi], y1 = yArr[lo], y2 = yArr[hi];
  return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
}

// hp_data_sets now loaded dynamically from bike data files

const gear_colors = ['#FF0000', '#00FFFF', '#00FF00', '#FFFF00', '#F012BE', '#FFFFFF'];
const freezeDashStyles = ['dot', 'dash', 'longdash', 'dashdot', 'solid'];
let freezeCount = 0;
let frozenConfigurations = []; // Store configurations instead of traces
let frozenTraces = [];
let frozenConnectorTraces = [];
let previousTraces = [];
let maxX = 0, maxY = 0;
let lastFamily = null;

const densePoints = 750;
let rpm_data_raw = [];
let rpmDense = [];
let hpDenseSets = {};

function initializeHPData(hp_data_sets) {
  rpm_data_raw = hp_data_sets[Object.keys(hp_data_sets)[0]].map(([r, _]) => r);
  const arr = [];
  const minR = rpm_data_raw[0];
  const maxR = rpm_data_raw[rpm_data_raw.length - 1];
  for (let i = 0; i <= densePoints; i++) arr.push(minR + (maxR - minR) * (i / densePoints));
  rpmDense = arr;
  
  hpDenseSets = {};
  for (const key in hp_data_sets) {
    const rpmArrRaw = hp_data_sets[key].map(([r, hp]) => r);
    const hpArrRaw = hp_data_sets[key].map(([r, hp]) => hp);
    hpDenseSets[key] = rpmDense.map(r => interp1(rpmArrRaw, hpArrRaw, r));
  }
}

// Helper function to create bike-specific data sets
function createBikeDataSets(bikeData) {
  const hp_data = bikeData.hp_data_sets;
  const rpm_raw = hp_data[Object.keys(hp_data)[0]].map(([r, _]) => r);
  
  const arr = [];
  const minR = rpm_raw[0];
  const maxR = rpm_raw[rpm_raw.length - 1];
  for (let i = 0; i <= densePoints; i++) arr.push(minR + (maxR - minR) * (i / densePoints));
  const rpmDense = arr;
  
  const hpDenseSets = {};
  for (const key in hp_data) {
    const rpmArrRaw = hp_data[key].map(([r, hp]) => r);
    const hpArrRaw = hp_data[key].map(([r, hp]) => hp);
    hpDenseSets[key] = rpmDense.map(r => interp1(rpmArrRaw, hpArrRaw, r));
  }
  
  return {
    rpmDense,
    hpDenseSets,
    hp_data_sets: hp_data,
    specifications: bikeData.specifications
  };
}

// Helper function to get bike-specific data by bike ID
function getBikeDataSets(bikeId) {
  if (!BIKES_DATA || !BIKES_DATA[bikeId]) {
    console.error(`Bike data not found for ID: ${bikeId}`);
    return null;
  }
  return createBikeDataSets(BIKES_DATA[bikeId]);
}

// Utility
function viewFamily(v) { return v === 'wheel' ? 'wheel' : (v === 'dyno' ? 'dyno' : (v.startsWith('accel') ? 'accel' : v)); }

// Generate frozen traces from stored configurations for current view
function regenerateFrozenTraces() {
  frozenTraces = [];
  frozenConnectorTraces = [];
  
  const currentView = document.getElementById('viewSelect').value;
  const currentFamily = viewFamily(currentView);
  
  // Store current global bike variables so we can restore them later
  const originalGlobals = {
    primary_drive,
    tire_circ_in, 
    Crr,
    CdA,
    gear_ratios
  };
  
  frozenConfigurations.forEach((config, configIndex) => {
    const dashStyle = (currentFamily === 'wheel') ? freezeDashStyles[configIndex % freezeDashStyles.length] : 'solid';
    const { bikeId, front, rear, hpKey, weightLb, shiftMs, shiftRpmSetting } = config;
    
    // Get bike-specific data for this frozen configuration
    const bikeData = getBikeDataSets(bikeId);
    if (!bikeData) {
      console.error(`Cannot regenerate frozen trace: bike data not found for ${bikeId}`);
      return;
    }
    
    // Temporarily set global bike variables to this frozen config's bike data
    const bikeSpecs = bikeData.specifications;
    primary_drive = bikeSpecs.primary_drive;
    tire_circ_in = bikeSpecs.tire_circ_in;
    Crr = bikeSpecs.Crr;
    CdA = bikeSpecs.CdA;
    gear_ratios = bikeSpecs.gear_ratios;
    
    const fd = rear / front;
    const rpmArr = bikeData.rpmDense;
    const hpArr = bikeData.hpDenseSets[hpKey];
    
    // Add spacer for legend grouping
    frozenTraces.push({ x:[null], y:[null], mode:'lines', name:'\u00A0', showlegend:true, hoverinfo:'skip', line:{color:'rgba(0,0,0,0)', width:0} });
    
    if (currentFamily === 'dyno') {
      const hpArrRaw = bikeData.hp_data_sets[hpKey].map(([r, hp]) => hp);
      const rpmArrRaw = bikeData.hp_data_sets[hpKey].map(([r, hp]) => r);
      const engTq = bikeData.hp_data_sets[hpKey].map(([rpm, hp]) => (hp * 5252) / rpm);
      
      // Convert to user's preferred units
      const hpConverted = hpArrRaw.map(hp => UnitConverter.convertPower(hp, userPreferences.power));
      const tqConverted = engTq.map(tq => UnitConverter.convertTorque(tq, userPreferences.torque));
      
      const lineColor = gear_colors[configIndex % gear_colors.length];
      frozenTraces.push({ x:rpmArrRaw, y:tqConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line:{ color: lineColor, shape:'spline', width:2 }, opacity:0.7 });
      frozenTraces.push({ x:rpmArrRaw, y:hpConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Power: %{y:.1f} ${userPreferences.power}<extra></extra>`, line:{ color: lineColor, shape:'spline', width:2 }, opacity:0.7 });
      const maxHP = Math.max(...hpConverted), maxTQ = Math.max(...tqConverted);
      const bikeName = BIKES_DATA[bikeId]?.name || bikeId;
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:bikeName, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:3 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:hpKey, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:2 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.power}: ${maxHP.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:2 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.torque}: ${maxTQ.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:2 } });
    }
    else if (currentFamily === 'accel') {
      const sim = simulateAccel(hpArr, rpmArr, fd, 0.02, weightLb, shiftMs, shiftRpmSetting);
      let xData, yData, showShift = false;
      
      // Convert speed data to user's preferred units  
      const speedConverted = sim.V.map(mph => UnitConverter.convertSpeed(mph, userPreferences.speed));
      
      // Convert distance data based on speed unit preference
      const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
      const distanceConverted = sim.S.map(ft => UnitConverter.convertDistance(ft, distanceUnit));
      
      if (currentView === 'accel_ts') { xData = sim.T; yData = speedConverted; showShift = true; }
      else if (currentView === 'accel_td') { xData = sim.T; yData = distanceConverted; }
      else if (currentView === 'accel_tg') { xData = sim.T; yData = sim.A.map(a=>a/g_mps2); }
      else if (currentView === 'accel_sg') { xData = speedConverted; yData = sim.A.map(a=>a/g_mps2); }
      else { xData = sim.T; yData = speedConverted; }
      
      const lineColor = gear_colors[configIndex % gear_colors.length];
      const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
      const displayWeight = UnitConverter.convertWeight(weightLb, weightUnit);
      const bikeName = BIKES_DATA[bikeId]?.name || bikeId;
      
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:bikeName, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:3, shape:'spline'} });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Weight: ${Math.round(displayWeight)} ${weightUnit}`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Shift Time: ${shiftMs} ms`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      // Create proper hover template for frozen traces with additional data
      let hoverTemplate, customData;
      if (currentView === 'accel_ts') {
        // Time vs Speed - add distance info
        customData = distanceConverted;
        const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
        hoverTemplate = `Time: %{x:.2f}s<br>Speed: %{y:.1f} ${userPreferences.speed}<br>Distance: %{customdata:.0f} ${distanceUnit}<extra></extra>`;
      } else if (currentView === 'accel_td') {
        // Time vs Distance - add speed info
        customData = speedConverted;
        const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
        hoverTemplate = `Time: %{x:.2f}s<br>Distance: %{y:.0f} ${distanceUnit}<br>Speed: %{customdata:.1f} ${userPreferences.speed}<extra></extra>`;
      } else if (currentView === 'accel_tg') {
        hoverTemplate = `Time: %{x:.2f}s<br>Accel: %{y:.2f} g<extra></extra>`;
      } else if (currentView === 'accel_sg') {
        hoverTemplate = `Speed: %{x:.1f} ${userPreferences.speed}<br>Accel: %{y:.2f} g<extra></extra>`;
      } else {
        hoverTemplate = `Time: %{x:.2f}s<br>Speed: %{y:.1f} ${userPreferences.speed}<extra></extra>`;
      }
      
      // Don't smooth G-force graphs
      const lineShape = (currentView === 'accel_tg' || currentView === 'accel_sg') ? 'linear' : 'spline';
      const traceData = { x:xData, y:yData, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate: hoverTemplate, line:{ color: lineColor, width:2, shape: lineShape }, opacity:0.7 };
      if (customData) traceData.customdata = customData;
      frozenTraces.push(traceData);
      
      if (showShift) {
        sim.shiftMarkers.forEach(m => {
          const yLabelPos = Math.max(0, (ACCEL_LABEL_BASE - configIndex * ACCEL_LABEL_STEP) * ACCEL_SPEED_YMAX);
          // ---- Vertical lines disabled for frozen traces ----
          //frozenConnectorTraces.push({ x:[m.t, m.t], y:[yLabelPos, m.v_mph], mode:'lines', line:{ color: gear_colors[m.gear-1], width:1 }, showlegend:false, hoverinfo:'skip', yaxis:'y' });
          //frozenConnectorTraces.push({ x:[m.t], y:[yLabelPos], mode:'text', text:[`${m.t.toFixed(2)} s`], textposition:'top center', textfont:{ color: gear_colors[m.gear-1] }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
          // ---------------------------------------------------
        });
      }
    }
    else if (currentFamily === 'wheel') {
      const { wt, shift_speed, shift_rpm } = computeShiftPoints(hpArr, fd, rpmArr, shiftRpmSetting);
      const truncate = document.getElementById("truncateCross").checked;
      const lineColor = gear_colors[configIndex % gear_colors.length];
      const bikeName = BIKES_DATA[bikeId]?.name || bikeId;
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:bikeName, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:3 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{ color: gear_colors[0], width: 2, dash: dashStyle, shape: 'spline' } });
      
      // Add gear traces (applying clip lines setting)
      for (let g = 1; g <= 6; g++) {
        const speeds = rpmArr.map(r => rpmToSpeed(r, bikeSpecs.gear_ratios[g], fd));
        const torques = hpToWheelTorqueAt(rpmArr, hpArr, bikeSpecs.gear_ratios[g], fd);
        let xPts = [], yPts = [], rpmPts = [];
        for (let i = 0; i < rpmArr.length; i++) {
          const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
          const inRange = !truncate || ((g > 1 ? sp >= shift_speed[g-1] : true) && (g < 6 ? sp <= shift_speed[g] : true));
          if (inRange) { 
            xPts.push(UnitConverter.convertSpeed(sp, userPreferences.speed)); 
            yPts.push(UnitConverter.convertTorque(tq, userPreferences.torque));
            rpmPts.push(rp);
          }
        }
        if (xPts.length) {
          let label = `Gear ${g}`;
          if (g < 6 && shift_rpm[g] != null) {
            const convertedShiftSpeed = UnitConverter.convertSpeed(shift_speed[g], userPreferences.speed);
            label += ` (${Math.round(shift_rpm[g])} RPM / ${convertedShiftSpeed.toFixed(1)} ${userPreferences.speed})`;
          }
          else if (g === 6) { 
            const red = rpmArr[rpmArr.length - 1]; 
            const sp = rpmToSpeed(red, bikeSpecs.gear_ratios[g], fd);
            const convertedSp = UnitConverter.convertSpeed(sp, userPreferences.speed);
            label += ` (${Math.round(red)} RPM / ${convertedSp.toFixed(1)} ${userPreferences.speed})`; 
          }
          frozenTraces.push({ x: xPts, y: yPts, customdata: rpmPts, mode: 'lines', name: label, showlegend: true, hovertemplate: `Speed: %{x:.1f} ${userPreferences.speed}<br>RPM: %{customdata:.0f} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line: { color: gear_colors[g-1], dash: dashStyle, width: 2, shape: 'spline', opacity: 0.3 } });
        }
      }
      
      // Add shift point connectors
      const maxYConverted = UnitConverter.convertTorque(maxY, userPreferences.torque);
      for (let g = 1; g <= 5; g++) {
        const xShift = shift_speed[g];
        if (xShift != null) {
          const yLabel = Math.max(0, (0.97 - configIndex * 0.03)) * maxYConverted;
          const speedsNext = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g + 1], fd));
          const idxNext = speedsNext.findIndex(s => s >= xShift);
          const torqueNext = idxNext !== -1 ? UnitConverter.convertTorque(wt[g + 1][idxNext], userPreferences.torque) : 0;
          const xShiftConverted = UnitConverter.convertSpeed(xShift, userPreferences.speed);
          frozenConnectorTraces.push({
            x: [xShiftConverted, xShiftConverted], y: [yLabel, torqueNext], mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: dashStyle },
            showlegend: false, hoverinfo: 'skip'
          });
          frozenConnectorTraces.push({
            x: [xShiftConverted], y: [yLabel], mode: 'text', text: [`${xShiftConverted.toFixed(1)} ${userPreferences.speed}`],
            textposition: 'top center', textfont: { color: gear_colors[g - 1] },
            showlegend: false, hoverinfo: 'skip', cliponaxis: false
          });
        }
      }
    }
  });
  
  // Restore original global bike variables
  primary_drive = originalGlobals.primary_drive;
  tire_circ_in = originalGlobals.tire_circ_in;
  Crr = originalGlobals.Crr;
  CdA = originalGlobals.CdA;
  gear_ratios = originalGlobals.gear_ratios;
}
function toggleControlVisibility() {
  const view = document.getElementById('viewSelect').value;
  const accel = view.startsWith('accel');
  ['weightLbLabel','weightLb','shiftMsLabel','shiftMs'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = accel ? 'inline-block' : 'none';
  });
  const clipEl = document.getElementById('clipControl');
  if (clipEl) clipEl.style.display = (view === 'wheel') ? 'inline-block' : 'none';
  
  // Adjust layout after visibility changes
  setTimeout(() => adjustLayout(), 50);
}

// Helper function to get current shift RPM setting
function getCurrentShiftRpmSetting() {
  const hiddenSelect = document.getElementById('shiftRpmSelect');
  if (!hiddenSelect) return 'optimal';
  
  const value = hiddenSelect.value;
  
  // If it's a number, return it as-is (custom RPM)
  if (value && !isNaN(parseFloat(value)) && value !== 'optimal' && value !== 'custom') {
    return parseFloat(value);
  }
  
  // Otherwise return 'optimal'
  return 'optimal';
}

// Shift points calc - with optional shift RPM override
function computeShiftPoints(hpArr, final_drive, rpmArr, shiftRpmOverride = null) {
  const wt = {}, spd = {};
  for (let g = 1; g <= 6; g++) {
    wt[g]  = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], final_drive);
    spd[g] = rpmArr.map(rpm => rpmToSpeed(rpm, gear_ratios[g], final_drive));
  }
  
  const shiftRpmSetting = shiftRpmOverride !== null ? shiftRpmOverride : getCurrentShiftRpmSetting();
  const shift_rpm = {}, shift_speed = {};
  
  for (let g = 1; g <= 5; g++) {
    let shiftRPM;
    
    if (shiftRpmSetting === 'optimal' || isNaN(shiftRpmSetting)) {
      // Original optimal shift point calculation
      const ratio  = gear_ratios[g + 1] / gear_ratios[g];
      const diff   = [];
      for (let i = 0; i < rpmArr.length; i++) {
        const rp    = rpmArr[i];
        const curTq = wt[g][i];
        const nxtTq = interp1(rpmArr, wt[g + 1], rp * ratio);
        diff.push(nxtTq - curTq);
      }
      let idx = diff.findIndex(d => d >= 0);
      if (idx === -1) shiftRPM = rpmArr[rpmArr.length - 1];
      else if (idx === 0) shiftRPM = rpmArr[0];
      else shiftRPM = lerp(rpmArr[idx - 1], diff[idx - 1], rpmArr[idx], diff[idx], 0);
    } else {
      // Use custom RPM value
      shiftRPM = parseFloat(shiftRpmSetting);
      // Clamp to valid RPM range
      shiftRPM = Math.max(rpmArr[0], Math.min(rpmArr[rpmArr.length - 1], shiftRPM));
    }
    
    // Ensure shift RPM is valid
    if (isNaN(shiftRPM)) {
      shiftRPM = rpmArr[rpmArr.length - 1]; // Fallback to max RPM
    }
    
    shift_rpm[g]   = shiftRPM;
    shift_speed[g] = rpmToSpeed(shiftRPM, gear_ratios[g], final_drive);
    
    // Ensure shift speed is valid
    if (isNaN(shift_speed[g])) {
      shift_speed[g] = rpmToSpeed(rpmArr[rpmArr.length - 1], gear_ratios[g], final_drive);
    }
  }
  return { wt, spd, shift_rpm, shift_speed };
}

// Accel sim with trapezoidal distance and shift time
function simulateAccel(hpArr, rpmArr, final_drive, dt = 0.02, mass_lb_param = getMassLb(), shift_ms = getShiftMs(), shiftRpmOverride = null) {
  function wheelTorqueAtSpeed(speed_mps, gear) {
    const speed_mph = speed_mps * MPS_TO_MPH;
    const rpm = Math.max(rpmArr[0], Math.min(rpmArr[rpmArr.length - 1], speedToRpm(speed_mph, gear_ratios[gear], final_drive)));
    const hp = interp1(rpmArr, hpArr, rpm);
    const tq_lbft = (hp * 5252) / rpm;
    const overall = primary_drive * gear_ratios[gear] * final_drive;
    const tq_wheel_Nm = tq_lbft * overall * LBF_FT_TO_NM;
    return tq_wheel_Nm / wheel_radius_m;
  }

  const mass_kg = mass_lb_param * LB_TO_KG;
  const max_rpm = rpmArr[rpmArr.length - 1];
  const { shift_speed } = computeShiftPoints(hpArr, final_drive, rpmArr, shiftRpmOverride);

  let g = 1, t = 0, v = 0, s = 0;
  let shiftCooldown = 0, pendingGear = null;
  const cooldownSteps = Math.max(0, Math.round((shift_ms / 1000) / dt));

  const T = [0], V = [0], A = [0], S = [0], G = [g], shiftMarkers = [];

  for (let step = 0; step < 20000; step++) {
    if (shiftCooldown === 0 && pendingGear === null && g <= 5) {
      const v_shift_mph = shift_speed[g];
      if (v_shift_mph !== undefined && v * MPS_TO_MPH >= v_shift_mph) {
        shiftMarkers.push({ t, v_mph: v * MPS_TO_MPH, gear: g });
        pendingGear = g + 1;
        shiftCooldown = cooldownSteps;
      }
    }

    let F_trac;
    if (shiftCooldown > 0) {
      F_trac = 0;
      shiftCooldown -= 1;
      if (shiftCooldown === 0 && pendingGear !== null) {
        g = pendingGear;
        pendingGear = null;
      }
    } else {
      F_trac = wheelTorqueAtSpeed(v, g);
    }

    const rpm_now = speedToRpm(v * MPS_TO_MPH, gear_ratios[g], final_drive);
    // Only terminate at redline if we've reached at least 35 seconds
    if (t >= 35 && g === 6 && rpm_now >= max_rpm) break;

    const F_roll = Crr * mass_kg * g_mps2;
    const F_aero = 0.5 * rho_air * CdA * v * v;
    const F_net = Math.max(0, F_trac - F_roll - F_aero);
    const a = F_net / mass_kg;

    // Trapezoid integration for distance over this step
    s += v * dt + 0.5 * a * dt * dt;
    v += a * dt;
    t += dt;

    T.push(t);
    V.push(v * MPS_TO_MPH);
    A.push(a);
    S.push(s * M_TO_FT);
    G.push(g);

    // Only allow early termination if we've reached at least 35 seconds
    if (t >= 35 && a < 0.01 && v > 60 * MPH_TO_MPS) {
      if (T.length > 200 && Math.abs(V[V.length - 1] - V[V.length - 200]) < 0.1) break;
    }
  }
  return { T, V, A, S, G, shiftMarkers };
}

// Precompute dyno y max
const dynoMaxHP = (() => {
  let maxVal = 0;
  Object.values(hp_data_sets).forEach(arr => arr.forEach(([rpm, v]) => { if (v > maxVal) maxVal = v; }));
  return Math.ceil(maxVal / 10) * 10;
})();

function populateHpDropdown() {
  const sel = document.getElementById('hpData');
  sel.innerHTML = '';
  const keys = Object.keys(hp_data_sets);
  keys.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  if (keys.includes('Stock')) sel.value = 'Stock'; else if (keys.length) sel.value = keys[0];
}

function populateShiftRpmDropdown() {
  const sel = document.getElementById('shiftRpmSelect');
  sel.innerHTML = '';
  
  // Add 'Optimal' as first option
  const optimalOpt = document.createElement('option');
  optimalOpt.value = 'optimal'; optimalOpt.textContent = 'Optimal'; sel.appendChild(optimalOpt);
  
  // Add 'Custom' option
  const customOpt = document.createElement('option');
  customOpt.value = 'custom'; customOpt.textContent = 'Custom'; sel.appendChild(customOpt);
  
  // Set default to 'Optimal'
  sel.value = 'optimal';
  
  // Make sure display shows 'Optimal'
  const displayText = document.getElementById('shiftRpmDisplayText');
  if (displayText) {
    displayText.textContent = 'Optimal';
  }
}

// Custom shift RPM dropdown functions
function toggleShiftRpmDropdown() {
  const options = document.getElementById('shiftRpmOptions');
  const arrow = document.querySelector('.dropdown-arrow');
  const isVisible = options.style.display !== 'none';
  
  if (isVisible) {
    options.style.display = 'none';
    arrow.style.transform = 'rotate(0deg)';
  } else {
    options.style.display = 'block';
    arrow.style.transform = 'rotate(180deg)';
    // Focus the input if it exists
    const customInput = document.getElementById('customShiftRpm');
    if (customInput) {
      setTimeout(() => customInput.focus(), 100);
    }
  }
}

function selectShiftRpm(value) {
  const displayText = document.getElementById('shiftRpmDisplayText');
  const hiddenSelect = document.getElementById('shiftRpmSelect');
  const options = document.getElementById('shiftRpmOptions');
  const arrow = document.querySelector('.dropdown-arrow');
  
  if (value === 'optimal') {
    displayText.textContent = 'Optimal';
    hiddenSelect.value = 'optimal';
  }
  
  // Close dropdown
  options.style.display = 'none';
  arrow.style.transform = 'rotate(0deg)';
  
  // Trigger plot update
  plotTorque(true);
}

function handleCustomRpmKeypress(event) {
  if (event.key === 'Enter') {
    const input = event.target;
    const value = parseInt(input.value);
    
    if (value && value >= 3400 && value <= 16000) {
      const displayText = document.getElementById('shiftRpmDisplayText');
      const hiddenSelect = document.getElementById('shiftRpmSelect');
      const options = document.getElementById('shiftRpmOptions');
      const arrow = document.querySelector('.dropdown-arrow');
      
      // Add the custom RPM as an option to the hidden select
      const existingCustom = hiddenSelect.querySelector(`option[value="${value}"]`);
      if (!existingCustom) {
        const customOption = document.createElement('option');
        customOption.value = value;
        customOption.textContent = `${value} RPM`;
        hiddenSelect.appendChild(customOption);
      }
      
      displayText.textContent = `${value} RPM`;
      hiddenSelect.value = value;
      
      // Close dropdown
      options.style.display = 'none';
      arrow.style.transform = 'rotate(0deg)';
      
      // Clear the input for next time
      input.value = '';
      
      // Trigger plot update
      plotTorque(true);
    } else {
      alert('Please enter an RPM value between 3400 and 16000');
    }
  }
}

function handleCustomRpmBlur() {
  // Close dropdown when input loses focus
  setTimeout(() => {
    const options = document.getElementById('shiftRpmOptions');
    const arrow = document.querySelector('.dropdown-arrow');
    options.style.display = 'none';
    arrow.style.transform = 'rotate(0deg)';
  }, 200);
}

function handleShiftRpmChange() {
  // This function handles the hidden select changes
  plotTorque(true);
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
  const dropdown = document.querySelector('.custom-shift-dropdown');
  const options = document.getElementById('shiftRpmOptions');
  const arrow = document.querySelector('.dropdown-arrow');
  
  if (dropdown && !dropdown.contains(event.target)) {
    if (options) options.style.display = 'none';
    if (arrow) arrow.style.transform = 'rotate(0deg)';
  }
});

// Fixed axis bounds calculated when bike data loads
let FIXED_AXIS_BOUNDS = null;

function calculateAxisBounds() {
  if (!hp_data_sets || !gear_ratios) return;
  
  // Find max HP across all datasets
  let maxHpValue = 0;
  let maxHpDataset = null;
  Object.entries(hp_data_sets).forEach(([key, data]) => {
    data.forEach(([rpm, hp]) => {
      if (hp > maxHpValue) {
        maxHpValue = hp;
        maxHpDataset = key;
      }
    });
  });
  
  // Use extreme sprocket combination (smallest front, largest rear) for accel sim
  const minFront = 12, maxRear = 53;
  const extremeFinalDrive = maxRear / minFront;
  
  // Use sprocket combination for wheel torque bounds that gives ~800 ft-lbs (13/50)
  const wheelTorqueFinalDrive = 50 / 13;
  
  // Get the max HP dataset
  const maxHpData = hp_data_sets[maxHpDataset];
  const rpmArrRaw = maxHpData.map(([r, hp]) => r);
  const hpArrRaw = maxHpData.map(([r, hp]) => hp);
  
  let maxWheelSpeed = 0, maxWheelTorque = 0, maxDynoHP = 0, maxDynoTorque = 0;
  
  // Calculate bounds for wheel torque graph using sprocket combo for ~800 ft-lbs
  for (const gear of Object.values(gear_ratios)) {
    for (let i = 0; i < rpmArrRaw.length; i++) {
      const rpm = rpmArrRaw[i], hp = hpArrRaw[i];
      const speed = rpmToSpeed(rpm, gear, wheelTorqueFinalDrive);
      const wheelTq = (hp * 5252 / rpm) * (primary_drive * gear * wheelTorqueFinalDrive);
      const engineTq = (hp * 5252) / rpm;
      
      if (speed > maxWheelSpeed) maxWheelSpeed = speed;
      if (wheelTq > maxWheelTorque) maxWheelTorque = wheelTq;
      if (hp > maxDynoHP) maxDynoHP = hp;
      if (engineTq > maxDynoTorque) maxDynoTorque = engineTq;
    }
  }
  
  // Calculate accel bounds using worst case scenario (max weight, max HP)
  const maxWeightLb = 1000; // Max from weight input
  const maxShiftTime = 300; // Max from shift time input
  const rpmDenseMax = rpmDense;
  const hpDenseMax = hpDenseSets[maxHpDataset];
  
  // Run accel sim with extreme parameters
  const accelSim = simulateAccel(hpDenseMax, rpmDenseMax, extremeFinalDrive, 0.02, maxWeightLb, maxShiftTime);
  const maxAccelTime = Math.max(...accelSim.T);
  const maxAccelSpeed = Math.max(...accelSim.V);
  const maxAccelDistance = Math.max(...accelSim.S);
  const maxAccelG = Math.max(...accelSim.A) / g_mps2;
  
  // Use full simulation distance to ensure Y-axis shows all data beyond 35 seconds
  const effectiveMaxDistance = maxAccelDistance;
  
  FIXED_AXIS_BOUNDS = {
    // Convert to user units on demand
    wheel: {
      maxSpeed: Math.max(160, Math.ceil(maxWheelSpeed * 1.1 / 10) * 10), // At least 160 MPH for speed axis
      maxTorque: Math.ceil(maxWheelTorque * 1.05 / 100) * 100 // Reduced margin from 10% to 5%
    },
    dyno: {
      maxHP: Math.ceil(maxDynoHP * 1.1 / 10) * 10,
      maxTorque: Math.ceil(maxDynoTorque * 1.1 / 10) * 10,
      minRPM: rpmArrRaw[0],
      maxRPM: rpmArrRaw[rpmArrRaw.length - 1]
    },
    accel: {
      maxTime: Math.max(35, Math.ceil(maxAccelTime * 1.1)), // At least 35 seconds
      maxSpeed: Math.max(160, Math.ceil(maxAccelSpeed * 1.1 / 10) * 10), // At least 160 MPH
      maxDistance: Math.ceil(effectiveMaxDistance * 2.0 / 100) * 100, // Use full distance with 100% extra margin to ensure visibility at 35s
      maxG: 1.0 // Always 1G max for G-force charts
    }
  };
}

function getPlotBounds() {
  // Legacy function - bounds are now pre-calculated in FIXED_AXIS_BOUNDS
  maxX = FIXED_AXIS_BOUNDS.wheel.maxSpeed;
  maxY = FIXED_AXIS_BOUNDS.wheel.maxTorque;
}

function freezeCurrentTraces() {
  // Store current configuration instead of generating traces
  const bikeId = document.getElementById('bikeSelect').value;
  const front = parseInt(document.getElementById('front').value);
  const rear = parseInt(document.getElementById('rear').value);
  const hpKey = document.getElementById('hpData').value;
  const weightLb = getMassLb();
  const shiftMs = getShiftMs();
  const shiftRpmSetting = getCurrentShiftRpmSetting();
  
  // Add configuration to frozen configurations array including bike ID
  frozenConfigurations.push({ bikeId, front, rear, hpKey, weightLb, shiftMs, shiftRpmSetting });
  freezeCount++;
  
  // Regenerate all frozen traces for current view
  regenerateFrozenTraces();
  
  const notif = document.getElementById('freezeNotification');
  notif.style.display = 'block'; setTimeout(()=>{ notif.style.display='none'; }, 2000);
  plotTorque(false); // <--- This line redraws the plot after freezing traces
}
function clearFrozenTraces() {
  // Reset to bike-specific defaults
  const specs = currentBikeData?.specifications;
  if (specs) {
    document.getElementById("front").value = specs.sprockets.front;
    document.getElementById("rear").value = specs.sprockets.rear;
  } else {
    // Fallback to hardcoded defaults if no bike data
    document.getElementById("front").value = "14";
    document.getElementById("rear").value = "48";
  }
  document.getElementById("hpData").value = "Stock";
  document.getElementById("shiftRpmSelect").value = "optimal";
  document.getElementById("shiftRpmDisplayText").textContent = "Optimal";
  document.getElementById("truncateCross").checked = false;
  frozenConfigurations = []; frozenTraces = []; freezeCount = 0; frozenConnectorTraces = [];
  plotTorque();
}

function plotTorque(animate = true) {
  const view = document.getElementById('viewSelect').value;
  const fam = viewFamily(view);
  toggleControlVisibility();

  // Remember the last view for comparison
  const lastView = window.lastPlotView;
  window.lastPlotView = view;
  
  // Regenerate frozen traces when view changes (only if we have configurations)
  if ((lastFamily !== null && fam !== lastFamily) || (lastView && lastView !== view)) {
    if (frozenConfigurations.length > 0) {
      regenerateFrozenTraces();
    }
  }
  lastFamily = fam;
  
  // Also regenerate if we have configurations but no traces (initial load)
  if (frozenConfigurations.length > 0 && frozenTraces.length === 0) {
    regenerateFrozenTraces();
  }
  
  // Always regenerate frozen traces if we have configurations (to respect current settings)
  if (frozenConfigurations.length > 0) {
    regenerateFrozenTraces();
  }

  const front = parseInt(document.getElementById("front").value);
  const rear  = parseInt(document.getElementById("rear").value);
  const hpKey = document.getElementById("hpData").value;
  const rpmArr = rpmDense;
  const hpArr  = hpDenseSets[hpKey];
  const fd = rear / front;
  const activeDash = (fam === 'wheel' && freezeCount > 1 && animate) ? freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length] : null;

  if (view === 'dyno') {
    const hpArrRaw = hp_data_sets[hpKey].map(([r, hp]) => hp);
    const rpmArrRaw = hp_data_sets[hpKey].map(([r, hp]) => r);
    const engTq = hp_data_sets[hpKey].map(([rpm, hp]) => (hp * 5252) / rpm);
    
    // Convert to user's preferred units
    const hpConverted = hpArrRaw.map(hp => UnitConverter.convertPower(hp, userPreferences.power));
    const tqConverted = engTq.map(tq => UnitConverter.convertTorque(tq, userPreferences.torque));
    
    const currentColor = gear_colors[freezeCount % gear_colors.length];
    const dynoTraces = [
      { x: rpmArrRaw, y: tqConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line:{ color: currentColor, shape:'spline', width:2 } },
      { x: rpmArrRaw, y: hpConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Power: %{y:.1f} ${userPreferences.power}<extra></extra>`, line:{ color: currentColor, shape:'spline', width:2 } }
    ];
    const maxHP = Math.max(...hpConverted), maxTQ = Math.max(...tqConverted);
    const legendTraces = [
      { x:[null], y:[null], mode:'lines', name:currentBikeData.name, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:3 } },
      { x:[null], y:[null], mode:'lines', name:hpKey, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:2 } },
      { x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.power}: ${maxHP.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:2 } },
      { x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.torque}: ${maxTQ.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:2 } }
    ];
    const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
    // Use fixed bounds for dyno chart
    const dynoMaxHP = UnitConverter.convertPower(FIXED_AXIS_BOUNDS.dyno.maxHP, userPreferences.power);
    const dynoMaxTorque = UnitConverter.convertTorque(FIXED_AXIS_BOUNDS.dyno.maxTorque, userPreferences.torque);
    const dynoYMax = Math.max(dynoMaxHP, dynoMaxTorque);
    const dynoLayout = { title: viewTitle, xaxis:{ title:'RPM', color:'white', autorange:false, range:[FIXED_AXIS_BOUNDS.dyno.minRPM, FIXED_AXIS_BOUNDS.dyno.maxRPM + 2000] }, yaxis:{ title:`${UnitConverter.getPowerLabel(userPreferences.power)} / ${UnitConverter.getTorqueLabel(userPreferences.torque)}`, color:'white', autorange:false, range:[0, dynoYMax] }, plot_bgcolor:'#111', paper_bgcolor:'#111', font:{ color:'white' }, transition:{ duration:1000, easing:'cubic-in-out' }, hovermode:'closest', hoverdistance:10 };
    const allDynoTraces = [...dynoTraces, ...legendTraces, ...frozenTraces];
    if (animate) Plotly.react('plot', allDynoTraces, dynoLayout, {responsive:true});
    else { const staticLayout = { ...dynoLayout }; delete staticLayout.transition; Plotly.newPlot('plot', allDynoTraces, staticLayout, {responsive:true}); }
    Plotly.Plots.resize(document.getElementById('plot'));
    previousTraces = []; return;
  }

  if (fam === 'accel') {
    const sim = simulateAccel(hpArr, rpmArr, fd, 0.02);
    let xData, yData, xTitle, yTitle, lockX=false, lockY=false, showShift=false;
    
    // Convert speed data to user's preferred units
    const speedConverted = sim.V.map(mph => UnitConverter.convertSpeed(mph, userPreferences.speed));
    
    // Convert distance data based on speed unit preference
    const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
    const distanceConverted = sim.S.map(ft => UnitConverter.convertDistance(ft, distanceUnit));
    
    // Use fixed bounds for all acceleration charts
    const accelMaxSpeed = UnitConverter.convertSpeed(FIXED_AXIS_BOUNDS.accel.maxSpeed, userPreferences.speed);
    const accelMaxDistance = UnitConverter.convertDistance(FIXED_AXIS_BOUNDS.accel.maxDistance, distanceUnit);
    
    if (view === 'accel_ts') { 
      xData = sim.T; 
      yData = speedConverted; 
      xTitle='Time (s)'; 
      yTitle=UnitConverter.getSpeedLabel(userPreferences.speed); 
      lockX=true; lockY=true; showShift=true; 
    }
    else if (view === 'accel_td') { 
      xData = sim.T; 
      yData = distanceConverted; 
      xTitle='Time (s)'; 
      yTitle=UnitConverter.getDistanceLabel(distanceUnit); 
    }
    else if (view === 'accel_tg') { xData = sim.T; yData = sim.A.map(a=>a/g_mps2); xTitle='Time (s)'; yTitle='Acceleration (g)'; }
    else if (view === 'accel_sg') { 
      xData = speedConverted; 
      yData = sim.A.map(a=>a/g_mps2); 
      xTitle=UnitConverter.getSpeedLabel(userPreferences.speed); 
      yTitle='Acceleration (g)'; 
    }
    else { xData = sim.T; yData = speedConverted; xTitle='Time (s)'; yTitle=UnitConverter.getSpeedLabel(userPreferences.speed); }

    const traces = [];
    const currentColor = gear_colors[freezeCount % gear_colors.length];
    const weightLb = getMassLb();
    const shiftMs = getShiftMs();
    
    // Add legend entries with configuration details
    const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
    const displayWeight = UnitConverter.convertWeight(weightLb, weightUnit);
    
    traces.push({ x:[null], y:[null], mode:'lines', name:currentBikeData.name, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:3, shape:'spline' } });
    traces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    traces.push({ x:[null], y:[null], mode:'lines', name:`Weight: ${Math.round(displayWeight)} ${weightUnit}`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    traces.push({ x:[null], y:[null], mode:'lines', name:`Shift Time: ${shiftMs} ms`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    // Create enhanced hover template with additional data for main traces
    let mainHoverTemplate, mainCustomData;
    if (view === 'accel_ts') {
      // Time vs Speed - add distance info
      mainCustomData = distanceConverted;
      mainHoverTemplate = `Time: %{x:.2f}s<br>Speed: %{y:.1f} ${userPreferences.speed}<br>Distance: %{customdata:.0f} ${distanceUnit}<extra></extra>`;
    } else if (view === 'accel_td') {
      // Time vs Distance - add speed info  
      mainCustomData = speedConverted;
      mainHoverTemplate = `Time: %{x:.2f}s<br>Distance: %{y:.0f} ${distanceUnit}<br>Speed: %{customdata:.1f} ${userPreferences.speed}<extra></extra>`;
    } else {
      // Keep original hover template for other views
      mainHoverTemplate = (xTitle.startsWith('Time') ? `Time: %{x:.2f}s` : `Speed: %{x:.1f} ${userPreferences.speed}`) + '<br>' +
        (yTitle.includes('Speed') ? `Speed: %{y:.1f} ${userPreferences.speed}` : 
         yTitle.includes('Distance') ? `Distance: %{y:.0f} ${yTitle.includes('(m)') ? 'm' : 'ft'}` : 
         `Accel: %{y:.2f} g`) +
        '<extra></extra>';
    }

    // Don't smooth G-force graphs
    const mainLineShape = (view === 'accel_tg' || view === 'accel_sg') ? 'linear' : 'spline';
    const mainTrace = { x:xData, y:yData, mode:'lines', name:'Acceleration View', showlegend:false, hoverinfo:'x+y',
      hovertemplate: mainHoverTemplate, line:{ color: currentColor, width:2, shape: mainLineShape } };
    if (mainCustomData) mainTrace.customdata = mainCustomData;
    traces.push(mainTrace);

    const connectorTraces = [];
    if (showShift) {
      sim.shiftMarkers.forEach(m => {
        const yLabelPos = Math.max(0, (ACCEL_LABEL_BASE - freezeCount * ACCEL_LABEL_STEP) * ACCEL_SPEED_YMAX);
        const shiftColor = gear_colors[Math.max(0, m.gear-1)];
        // ---- These two lines draw the vertical lines and labels ----
        //connectorTraces.push({ x:[m.t, m.t], y:[yLabelPos, m.v_mph], mode:'lines', line:{ color: shiftColor, width:2 }, showlegend:false, hoverinfo:'skip' });
        //connectorTraces.push({ x:[m.t], y:[yLabelPos], mode:'text', text:[`${m.t.toFixed(2)} s`], textposition:'top center', textfont:{ color: shiftColor }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
        // -----------------------------------------------------------
      });
    }

    const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
    
    // Set fixed axis ranges based on chart type
    let xRange, yRange;
    if (view === 'accel_ts') {
      xRange = [0, FIXED_AXIS_BOUNDS.accel.maxTime];
      yRange = [0, accelMaxSpeed];
    } else if (view === 'accel_td') {
      xRange = [0, FIXED_AXIS_BOUNDS.accel.maxTime];
      yRange = [0, accelMaxDistance];
    } else if (view === 'accel_tg') {
      xRange = [0, FIXED_AXIS_BOUNDS.accel.maxTime];
      yRange = [0, FIXED_AXIS_BOUNDS.accel.maxG];
    } else if (view === 'accel_sg') {
      xRange = [0, accelMaxSpeed];
      yRange = [0, FIXED_AXIS_BOUNDS.accel.maxG];
    } else {
      xRange = [0, FIXED_AXIS_BOUNDS.accel.maxTime];
      yRange = [0, accelMaxSpeed];
    }
    
    const layout = {
      title: viewTitle,
      xaxis: { title:xTitle, color:'white', range:xRange },
      yaxis: { title:yTitle, color:'white', range:yRange },
      plot_bgcolor:'#111', paper_bgcolor:'#111', font:{ color:'white' },
      hovermode:'closest', hoverdistance:10, transition:{ duration:1000, easing:'cubic-in-out' }
    };

    const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
    if (animate) Plotly.react('plot', allTraces, layout, { responsive:true });
    else { const staticLayout = { ...layout }; delete staticLayout.transition; Plotly.newPlot('plot', allTraces, staticLayout, { responsive:true }); }
    previousTraces = [...traces, ...connectorTraces];
    Plotly.Plots.resize(document.getElementById('plot'));
    return;
  }

  // Wheel TQ
  const { wt, spd, shift_rpm, shift_speed } = computeShiftPoints(hpArr, fd, rpmArr);
  const truncate = document.getElementById("truncateCross").checked;
  const traces = [];
  const groupLabel = `(F${front}/R${rear} ${hpKey})`;
  traces.push({ x:[null], y:[null], mode:'lines', name:currentBikeData.name, showlegend:true, hoverinfo:'skip', line:{ color: gear_colors[0], width:3, shape:'spline' } });
  traces.push({ x:[null], y:[null], mode:'lines', name:groupLabel, showlegend:true, hoverinfo:'skip', line:{ color: gear_colors[0], width:2, shape:'spline' } });

  for (let g = 1; g <= 6; g++) {
    const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
    const torques = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);
    let xPts = [], yPts = [], rpmPts = [];
    for (let i = 0; i < rpmArr.length; i++) {
      const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
      const inRange = !truncate || ((g > 1 ? sp >= shift_speed[g-1] : true) && (g < 6 ? sp <= shift_speed[g] : true));
      if (inRange) { 
        xPts.push(UnitConverter.convertSpeed(sp, userPreferences.speed)); 
        yPts.push(UnitConverter.convertTorque(tq, userPreferences.torque)); 
        rpmPts.push(rp); 
      }
    }
    if (xPts.length) {
      let label = `Gear ${g}`;
      if (g < 6 && shift_rpm[g] != null) {
        const convertedShiftSpeed = UnitConverter.convertSpeed(shift_speed[g], userPreferences.speed);
        label += ` (${Math.round(shift_rpm[g])} RPM / ${convertedShiftSpeed.toFixed(1)} ${userPreferences.speed})`;
      }
      else if (g === 6) { 
        const red = rpmArr[rpmArr.length - 1]; 
        const sp = rpmToSpeed(red, gear_ratios[g], fd); 
        const convertedSp = UnitConverter.convertSpeed(sp, userPreferences.speed);
        label += ` (${Math.round(red)} RPM / ${convertedSp.toFixed(1)} ${userPreferences.speed})`; 
      }
      traces.push({ x:xPts, y:yPts, customdata:rpmPts, mode:'lines', name:label, line:{ color:gear_colors[g-1], width:2, shape:'spline' }, opacity:1, hovertemplate:`Speed: %{x:.1f} ${userPreferences.speed}<br>RPM: %{customdata:.0f} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>` });
    }
  }

  const connectorTraces = [];
  // Use fixed axis bounds for wheel torque chart - ensure at least 160 MPH equivalent
  const wheelMaxSpeedMPH = Math.max(160, FIXED_AXIS_BOUNDS.wheel.maxSpeed);
  const maxXConverted = UnitConverter.convertSpeed(wheelMaxSpeedMPH, userPreferences.speed);
  const maxYConverted = UnitConverter.convertTorque(FIXED_AXIS_BOUNDS.wheel.maxTorque, userPreferences.torque);
  
  for (let g = 1; g <= 5; g++) {
    const xShift = shift_speed[g];
    if (xShift != null) {
      const baseRatio = 0.97, stepRatio = 0.03;
      const yLabel = Math.max(0, baseRatio - freezeCount * stepRatio) * maxYConverted;
      const speedsNext = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g + 1], fd));
      const idxNext = speedsNext.findIndex(s => s >= xShift);
      const torqueNext = idxNext !== -1 ? UnitConverter.convertTorque(wt[g + 1][idxNext], userPreferences.torque) : 0;
      const xShiftConverted = UnitConverter.convertSpeed(xShift, userPreferences.speed);
      connectorTraces.push({ x:[xShiftConverted, xShiftConverted], y:[yLabel, torqueNext], mode:'lines', line:{ color:gear_colors[g - 1], width:2, dash: activeDash || 'solid' }, showlegend:false, hoverinfo:'skip' });
      connectorTraces.push({ x:[xShiftConverted], y:[yLabel], mode:'text', text:[`${xShiftConverted.toFixed(1)} ${userPreferences.speed}`], textposition:'top center', textfont:{ color:gear_colors[g - 1] }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
    }
  }

  const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
  const layout = { transition:{ duration:1000, easing:'cubic-in-out' }, hovermode:'closest', hoverdistance:10, title: viewTitle, xaxis:{title:UnitConverter.getSpeedLabel(userPreferences.speed), color:'white', range:[0,maxXConverted]}, yaxis:{title:`Wheel ${UnitConverter.getTorqueLabel(userPreferences.torque)}`, color:'white', range:[0,maxYConverted]}, plot_bgcolor:'#111', paper_bgcolor:'#111', font:{color:'white'} };
  const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
  if (animate) Plotly.react('plot', allTraces, layout, {responsive: true});
  else { const staticLayout = { ...layout }; delete staticLayout.transition; Plotly.newPlot('plot', allTraces, staticLayout, {responsive: true}); }
  previousTraces = [...traces, ...connectorTraces];
  Plotly.Plots.resize(document.getElementById('plot'));
}

function adjustLayout() {
  const plot = document.getElementById('plot');
  const controls = document.querySelector('.controls');
  const buttonRow = document.querySelector('.button-row');
  const h1 = document.querySelector('h1');
  
  // Calculate available height
  const windowHeight = window.innerHeight;
  const windowWidth = window.innerWidth;
  
  // Get actual heights of elements
  const controlsHeight = controls ? controls.offsetHeight : 0;
  const buttonRowHeight = buttonRow ? buttonRow.offsetHeight : 0;
  const h1Height = h1 ? h1.offsetHeight : 0;
  
  // Calculate available space for plot (with some padding)
  const availableHeight = windowHeight - controlsHeight - buttonRowHeight - h1Height - 60; // 60px padding
  const availableWidth = windowWidth - 20; // 20px padding
  
  // Calculate ideal plot dimensions maintaining 16:9 aspect ratio
  let plotWidth = Math.min(availableWidth, availableHeight * (16/9));
  let plotHeight = plotWidth * (9/16);
  
  // If calculated height is too large, constrain by height instead
  if (plotHeight > availableHeight) {
    plotHeight = availableHeight;
    plotWidth = plotHeight * (16/9);
  }
  
  // Apply the calculated dimensions
  if (plot) {
    plot.style.width = `${plotWidth}px`;
    plot.style.height = `${plotHeight}px`;
    plot.style.maxWidth = `${plotWidth}px`;
    plot.style.maxHeight = `${plotHeight}px`;
  }
}

// Global bikes data
let BIKES_DATA = null;

// Simple bike data loader
async function loadBikesData() {
  const response = await fetch('bikes-data.json');
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  BIKES_DATA = await response.json();
  console.log('Bikes data loaded:', Object.keys(BIKES_DATA));
  return true;
}

// Bike management functions
function initializeBikes() {
  if (!BIKES_DATA) {
    console.error('No bike data available');
    return false;
  }
  
  try {
    // Load default bike
    currentBikeData = BIKES_DATA['kawasaki-zx4rr'];
    
    // Update global variables with bike data
    loadBikeData();
    
    // Populate bike selection dropdown
    populateBikeDropdown();
    
    // Update UI with bike name
    updateBikeTitle();
    
    console.log('Bikes initialized successfully');
    return true;
  } catch (error) {
    console.error('Failed to initialize bikes:', error);
    return false;
  }
}

function loadBikeData() {
  if (!currentBikeData) return;
  
  const specs = currentBikeData.specifications;
  
  // Load bike specifications into global variables
  primary_drive = specs.primary_drive;
  tire_circ_in = specs.tire_circ_in;
  gear_ratios = specs.gear_ratios;
  Crr = specs.Crr;
  CdA = specs.CdA;
  hp_data_sets = currentBikeData.hp_data_sets;
  
  // Initialize HP interpolation data
  initializeHPData(hp_data_sets);
  
  // Calculate axis bounds for plots
  calculateAxisBounds();
  
  // Update sprocket controls with bike-specific defaults
  const frontInput = document.getElementById('front');
  const rearInput = document.getElementById('rear');
  
  if (frontInput) {
    frontInput.value = specs.sprockets.front;
  }
  
  if (rearInput) {
    rearInput.value = specs.sprockets.rear;
  }
  
  // Update weight default
  const weightInput = document.getElementById('weightLb');
  if (weightInput) {
    weightInput.value = specs.default_weight_lb;
  }
}

function populateBikeDropdown() {
  const bikeSelect = document.getElementById('bikeSelect');
  if (!bikeSelect || !BIKES_DATA) return;
  
  bikeSelect.innerHTML = ''; // Clear existing options
  
  // Populate from bikes data
  Object.keys(BIKES_DATA).forEach(bikeId => {
    const bike = BIKES_DATA[bikeId];
    const option = document.createElement('option');
    option.value = bikeId;
    option.textContent = bike.name;
    option.selected = bikeId === 'kawasaki-zx4rr'; // Default selection
    bikeSelect.appendChild(option);
  });
}

function updateBikeTitle() {
  const titleElement = document.getElementById('bikeTitle');
  if (titleElement && currentBikeData) {
    titleElement.textContent = currentBikeData.name;
  }
}

function changeBike() {
  const bikeSelect = document.getElementById('bikeSelect');
  if (!bikeSelect || !bikeSelect.value || !BIKES_DATA) return;
  
  try {
    currentBikeData = BIKES_DATA[bikeSelect.value];
    if (!currentBikeData) {
      throw new Error(`Bike ${bikeSelect.value} not found`);
    }
    
    loadBikeData();
    updateBikeTitle();
    
    // Refresh the UI
    populateHpDropdown();
    plotTorque(true);
    
    console.log('Switched to bike:', currentBikeData.name);
  } catch (error) {
    console.error('Failed to load bike:', error);
  }
}

async function init() { 
  loadUnitPreferences(); // Load saved preferences
  
  // Load bike data first
  const dataLoaded = await loadBikesData();
  
  if (dataLoaded) {
    // Initialize bikes if data loaded successfully
    const bikesLoaded = initializeBikes();
    if (!bikesLoaded) {
      console.error('Failed to initialize bikes, using defaults');
    }
  } else {
    console.error('Failed to load bike data, using hardcoded defaults');
    // Set fallback bike dropdown
    const bikeSelect = document.getElementById('bikeSelect');
    if (bikeSelect) {
      bikeSelect.innerHTML = '<option value="">No bikes available</option>';
    }
  }
  
  populateHpDropdown(); 
  populateShiftRpmDropdown(); 
  getPlotBounds(); 
  plotTorque(); 
  toggleControlVisibility(); 
  adjustLayout();
}

document.addEventListener('DOMContentLoaded', init);
window.addEventListener('resize', () => {
  adjustLayout();
  setTimeout(() => plotTorque(false), 100); // Small delay to let layout settle
});
</script>
</body>
</html>
