<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ZX-4RR Dyno App</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { 
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); 
      color: #e8e8e8; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      padding: 10px;
      min-height: 100vh;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    h1 {
      text-align: center;
      color: #ffffff;
      font-weight: 300;
      font-size: 2.2em;
      margin: 10px 0 20px 0;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    #plot { 
      width: 98%; 
      max-width: calc(100vh - 200px); 
      aspect-ratio: 16 / 9; 
      max-height: calc(100vh - 200px); 
      margin: auto;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .controls { 
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 15px;
      padding: 12px 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      width: calc(100% - 20px);
      margin: 0 auto 15px auto;
      overflow-x: auto;
      min-width: 0;
    }
    
    .button-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    label { 
      user-select: none;
      font-weight: 500;
      color: #d0d0d0;
      font-size: 12px;
      white-space: nowrap;
      margin-right: 4px;
    }
    
    select, input[type="number"] {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      color: #e8e8e8;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      min-width: 60px;
      width: auto;
      transition: all 0.3s ease;
    }
    
    select:hover, input[type="number"]:hover {
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.3);
    }
    
    select:focus, input[type="number"]:focus {
      outline: none;
      background: rgba(255,255,255,0.15);
      border-color: #4a9eff;
      box-shadow: 0 0 0 2px rgba(74,158,255,0.2);
    }
    
    select option {
      background: #2a2a2a;
      color: #e8e8e8;
    }
    
    button {
      background: linear-gradient(145deg, #4a9eff 0%, #357abd 100%);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 8px rgba(74,158,255,0.3);
      min-width: 70px;
    }
    
    button:hover {
      background: linear-gradient(145deg, #5ba3ff 0%, #3d82c7 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(74,158,255,0.4);
    }
    
    button:active {
      transform: translateY(0);
      box-shadow: 0 2px 6px rgba(74,158,255,0.3);
    }
    
    input[type="checkbox"] {
      margin-right: 4px;
      accent-color: #4a9eff;
      transform: scale(1.1);
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    @media (max-width: 1400px) {
      .controls {
        gap: 6px;
        padding: 10px 6px;
      }
      
      label {
        font-size: 11px;
      }
      
      select, input[type="number"] {
        font-size: 11px;
        padding: 5px 6px;
        min-width: 50px;
      }
    }
    
    @media (max-width: 1200px) {
      .controls {
        gap: 4px;
        padding: 8px 4px;
      }
      
      label {
        font-size: 10px;
      }
      
      select, input[type="number"] {
        font-size: 10px;
        padding: 4px 5px;
        min-width: 45px;
      }
      
      .control-group {
        gap: 3px;
      }
    }
    
    @media (max-width: 768px) {
      .controls {
        flex-wrap: wrap;
        gap: 8px;
        padding: 12px;
      }
      
      .control-group {
        flex-shrink: 1;
      }
      
      h1 {
        font-size: 1.8em;
      }
      
      #plot {
        max-height: calc(100vh - 250px);
      }
    }
    
    /* Settings Icon and Panel Styles */
    .settings-icon {
      font-size: 18px;
      cursor: pointer;
      color: #4a9eff;
      transition: color 0.3s ease, transform 0.2s ease;
      display: flex;
      align-items: center;
      padding: 4px;
    }
    
    .settings-icon:hover {
      color: #5ba3ff;
      transform: rotate(90deg);
    }
    
    .settings-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      z-index: 9999;
      backdrop-filter: blur(5px);
    }
    
    .settings-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 24px;
      min-width: 300px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .settings-title {
      font-size: 18px;
      font-weight: 600;
      color: #ffffff;
    }
    
    .settings-close {
      font-size: 24px;
      cursor: pointer;
      color: #999;
      transition: color 0.3s ease;
    }
    
    .settings-close:hover {
      color: #fff;
    }
    
    .settings-group {
      margin-bottom: 16px;
    }
    
    .settings-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: #d0d0d0;
      font-size: 14px;
    }
    
    .settings-group select {
      width: 100%;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      color: #e8e8e8;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    .settings-group select:focus {
      outline: none;
      background: rgba(255,255,255,0.15);
      border-color: #4a9eff;
      box-shadow: 0 0 0 2px rgba(74,158,255,0.2);
    }
    
    .settings-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 24px;
    }
    
    .settings-btn {
      background: linear-gradient(145deg, #4a9eff 0%, #357abd 100%);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 8px rgba(74,158,255,0.3);
    }
    
    .settings-btn:hover {
      background: linear-gradient(145deg, #5ba3ff 0%, #3d82c7 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(74,158,255,0.4);
    }
    
    .settings-btn.secondary {
      background: rgba(255,255,255,0.1);
      box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    }
    
    .settings-btn.secondary:hover {
      background: rgba(255,255,255,0.15);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  
  <!-- Settings Panel -->
  <div id="settingsPanel" class="settings-panel" onclick="closeSettings(event)">
    <div class="settings-content" onclick="event.stopPropagation()">
      <div class="settings-header">
        <div class="settings-title">Unit Preferences</div>
        <div class="settings-close" onclick="closeSettings()">&times;</div>
      </div>
      
      <div class="settings-group">
        <label for="powerUnit">Power Unit:</label>
        <select id="powerUnit" onchange="updateUnitPreferences()">
          <option value="HP">HP (Horsepower)</option>
          <option value="BHP">BHP (Brake Horsepower)</option>
          <option value="PS">PS (Pferdestärke)</option>
          <option value="kW">kW (Kilowatts)</option>
        </select>
      </div>
      
      <div class="settings-group">
        <label for="torqueUnit">Torque Unit:</label>
        <select id="torqueUnit" onchange="updateUnitPreferences()">
          <option value="lb-ft">lb-ft (pound-feet)</option>
          <option value="Nm">N⋅m (Newton-meters)</option>
          <option value="kgfm">kgf⋅m (kilogram-force meters)</option>
        </select>
      </div>
      
      <div class="settings-group">
        <label for="speedUnit">Speed Unit:</label>
        <select id="speedUnit" onchange="updateUnitPreferences()">
          <option value="MPH">MPH (miles per hour)</option>
          <option value="kmh">km/h (kilometers per hour)</option>
        </select>
      </div>
      
      <div class="settings-buttons">
        <button class="settings-btn secondary" onclick="resetUnitsToDefault()">Reset to Default</button>
        <button class="settings-btn" onclick="closeSettings()">Done</button>
      </div>
    </div>
  </div>

  <h1 style="text-align:center;">Kawasaki ZX-4R</h1>
  <div class="controls">
    <div class="control-group">
      <div class="settings-icon" onclick="openSettings()" title="Units Settings">⚙️</div>
    </div>

    <div class="control-group">
      <label for="front">F-Sprocket:</label>
      <select id="front" onchange="plotTorque(true)">
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14" selected>14</option>
        <option value="15">15</option>
      </select>
    </div>

    <div class="control-group">
      <label for="rear">R-Sprocket:</label>
      <select id="rear" onchange="plotTorque(true)">
        <option value="43">43</option>
        <option value="44">44</option>
        <option value="45">45</option>
        <option value="46">46</option>
        <option value="47">47</option>
        <option value="48" selected>48</option>
        <option value="49">49</option>
        <option value="50">50</option>
        <option value="51">51</option>
        <option value="52">52</option>
        <option value="53">53</option>
      </select>
    </div>

    <div class="control-group">
      <label for="hpData">ECU Tune:</label>
      <select id="hpData" onchange="plotTorque(true)"></select>
    </div>

    <div class="control-group">
      <label for="shiftRpmSelect">Shift RPM:</label>
      <select id="shiftRpmSelect" onchange="plotTorque(true)"></select>
    </div>

    <div class="control-group">
      <label for="viewSelect">Plot:</label>
      <select id="viewSelect" onchange="plotTorque(true)">
        <option value="wheel" selected>Wheel TQ / Shift</option>
        <option value="dyno">Power Curves</option>
        <option value="accel_ts">Time vs Speed</option>
        <option value="accel_td">Time vs Distance</option>
        <option value="accel_tg">Time vs G's</option>
        <option value="accel_sg">Speed vs G's</option>
      </select>
    </div>

    <!-- Accel-only controls -->
    <div class="control-group">
      <label id="weightLbLabel" for="weightLb">Weight (lb):</label>
      <input id="weightLb" type="number" value="580" min="300" max="1000" step="1" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <label id="shiftMsLabel" for="shiftMs">Shift Time (ms):</label>
      <input id="shiftMs" type="number" value="80" min="0" max="300" step="10" onchange="plotTorque(true)">
    </div>

    <div class="control-group">
      <input type="checkbox" id="truncateCross" onchange="plotTorque(false)">
      <label for="truncateCross">Clip Curves</label>
    </div>
  </div>
  
  <div class="button-row">
    <button onclick="freezeCurrentTraces()">Compare</button>
    <button onclick="clearFrozenTraces()">Reset</button>
  </div>

  <div id="plot" style="position: relative;">
    <div id="freezeNotification" style="
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(255,255,255,0.9); color: #111; padding: 8px 12px;
        border-radius: 4px; font-weight: bold; display: none; z-index: 1000;">
      Select New Options!
    </div>
  </div>

<script>
// -------- Unit Conversion System --------
const UnitConverter = {
  // Conversion factors to base units (HP for power, lb-ft for torque, MPH for speed)
  power: {
    'HP': 1.0,
    'BHP': 1.0, // BHP ≈ HP
    'PS': 1.0 / 0.98592, // 1 PS = 0.98592 HP
    'kW': 1.0 / 0.746  // 1 HP = 0.746 kW
  },
  torque: {
    'lb-ft': 1.0,
    'Nm': 1.0 / 1.356, // 1 lb-ft = 1.356 N⋅m
    'kgfm': 1.0 / 9.807 // 1 kgf⋅m = 9.807 N⋅m
  },
  speed: {
    'MPH': 1.0,
    'kmh': 1.0 / 1.609 // 1 MPH = 1.609 km/h
  },
  distance: {
    'ft': 1.0,
    'm': 1.0 / 3.28084 // 1 ft = 0.3048 m
  },
  weight: {
    'lb': 1.0,
    'kg': 1.0 / 2.20462 // 1 lb = 0.453592 kg
  },
  
  // Convert from base unit to target unit
  convertPower: function(value, targetUnit) {
    return value / this.power[targetUnit];
  },
  
  convertTorque: function(value, targetUnit) {
    return value / this.torque[targetUnit];
  },
  
  convertSpeed: function(value, targetUnit) {
    return value / this.speed[targetUnit];
  },
  
  convertDistance: function(value, targetUnit) {
    return value / this.distance[targetUnit];
  },
  
  convertWeight: function(value, targetUnit) {
    return value * this.weight[targetUnit];
  },
  
  // Format values with appropriate precision and unit symbol
  formatPower: function(value, unit) {
    const converted = this.convertPower(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatTorque: function(value, unit) {
    const converted = this.convertTorque(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatSpeed: function(value, unit) {
    const converted = this.convertSpeed(value, unit);
    return `${converted.toFixed(1)} ${unit}`;
  },
  
  formatDistance: function(value, unit) {
    const converted = this.convertDistance(value, unit);
    return `${converted.toFixed(0)} ${unit}`;
  },
  
  formatWeight: function(value, unit) {
    const converted = this.convertWeight(value, unit);
    return `${converted.toFixed(0)} ${unit}`;
  },
  
  // Get proper unit labels for axes
  getPowerLabel: function(unit) {
    const labels = {
      'HP': 'Horsepower (HP)',
      'BHP': 'Brake Horsepower (BHP)', 
      'PS': 'Pferdestärke (PS)',
      'kW': 'Kilowatts (kW)'
    };
    return labels[unit] || 'Power';
  },
  
  getTorqueLabel: function(unit) {
    const labels = {
      'lb-ft': 'Torque (lb-ft)',
      'Nm': 'Torque (N⋅m)',
      'kgfm': 'Torque (kgf⋅m)'
    };
    return labels[unit] || 'Torque';
  },
  
  getSpeedLabel: function(unit) {
    const labels = {
      'MPH': 'Speed (MPH)',
      'kmh': 'Speed (km/h)'
    };
    return labels[unit] || 'Speed';
  },
  
  getDistanceLabel: function(unit) {
    const labels = {
      'ft': 'Distance (ft)',
      'm': 'Distance (m)'
    };
    return labels[unit] || 'Distance';
  },
  
  // Get the appropriate distance unit based on speed unit
  getDistanceUnit: function(speedUnit) {
    return speedUnit === 'kmh' ? 'm' : 'ft';
  },
  
  getWeightLabel: function(unit) {
    const labels = {
      'lb': 'Weight (lb)',
      'kg': 'Weight (kg)'
    };
    return labels[unit] || 'Weight';
  },
  
  // Get the appropriate weight unit based on speed unit
  getWeightUnit: function(speedUnit) {
    return speedUnit === 'kmh' ? 'kg' : 'lb';
  }
};

// -------- User Preferences --------
let userPreferences = {
  power: 'HP',
  torque: 'lb-ft',
  speed: 'MPH'
};

// Load preferences from localStorage
function loadUnitPreferences() {
  try {
    const saved = localStorage.getItem('dynoChartUnitPrefs');
    if (saved) {
      const prefs = JSON.parse(saved);
      userPreferences = { ...userPreferences, ...prefs };
    }
  } catch (e) {
    console.warn('Failed to load unit preferences:', e);
  }
  
  // Update UI selectors
  document.getElementById('powerUnit').value = userPreferences.power;
  document.getElementById('torqueUnit').value = userPreferences.torque;
  document.getElementById('speedUnit').value = userPreferences.speed;
  
  // Update weight control to match speed units
  updateWeightControl();
}

// Save preferences to localStorage
function saveUnitPreferences() {
  try {
    localStorage.setItem('dynoChartUnitPrefs', JSON.stringify(userPreferences));
  } catch (e) {
    console.warn('Failed to save unit preferences:', e);
  }
}

// Update preferences from UI
function updateUnitPreferences() {
  userPreferences.power = document.getElementById('powerUnit').value;
  userPreferences.torque = document.getElementById('torqueUnit').value;
  userPreferences.speed = document.getElementById('speedUnit').value;
  
  saveUnitPreferences();
  updateWeightControl(); // Update weight control units
  plotTorque(false); // Re-render with new units
}

// Track the base weight in pounds to avoid conversion errors
let baseWeightLb = 580;

// Update weight control based on speed unit preference
function updateWeightControl() {
  const newWeightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  const oldWeightUnit = UnitConverter.getWeightUnit(userPreferences.speed === 'kmh' ? 'MPH' : 'kmh'); // Get opposite unit
  const weightLabel = document.getElementById('weightLbLabel');
  const weightInput = document.getElementById('weightLb');
  
  if (weightLabel && weightInput) {
    // Only update if the unit actually changed
    const currentLabel = weightLabel.textContent;
    const expectedLabel = UnitConverter.getWeightLabel(newWeightUnit) + ':';
    
    if (currentLabel !== expectedLabel) {
      // Convert from base weight in pounds
      const convertedValue = UnitConverter.convertWeight(baseWeightLb, newWeightUnit);
      
      // Update label and value
      weightLabel.textContent = expectedLabel;
      weightInput.value = Math.round(convertedValue);
    }
  }
}

// Reset to defaults
function resetUnitsToDefault() {
  userPreferences = {
    power: 'HP',
    torque: 'lb-ft',
    speed: 'MPH'
  };
  
  document.getElementById('powerUnit').value = userPreferences.power;
  document.getElementById('torqueUnit').value = userPreferences.torque;
  document.getElementById('speedUnit').value = userPreferences.speed;
  
  // Reset weight to default 580 lb equivalent in preferred units
  baseWeightLb = 580;
  const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  const weightInput = document.getElementById('weightLb');
  const weightLabel = document.getElementById('weightLbLabel');
  
  if (weightInput && weightLabel) {
    const convertedWeight = UnitConverter.convertWeight(baseWeightLb, weightUnit);
    weightInput.value = Math.round(convertedWeight);
    weightLabel.textContent = UnitConverter.getWeightLabel(weightUnit) + ':';
  }
  
  saveUnitPreferences();
  plotTorque(false);
}

// Settings panel functions
function openSettings() {
  document.getElementById('settingsPanel').style.display = 'block';
}

function closeSettings(event) {
  if (!event || event.target.id === 'settingsPanel' || event.target.classList.contains('settings-close')) {
    document.getElementById('settingsPanel').style.display = 'none';
  }
}

// -------- Constants & data --------
const primary_drive = 2.029;
const tire_circ_in  = 77.15;
const gear_ratios   = {1:2.92, 2:2.05, 3:1.62, 4:1.33, 5:1.15, 6:1.03};

// Accel sim - now handles different weight units
function getMassLb() {
  const el = document.getElementById('weightLb');
  const v = el ? parseFloat(el.value) : 580;
  const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
  
  if (Number.isFinite(v) && v > 0) {
    // Update base weight when user changes input
    baseWeightLb = weightUnit === 'kg' ? v * 2.20462 : v;
    return baseWeightLb;
  }
  return 580; // Default in lb
}
function getShiftMs() {
  const el = document.getElementById('shiftMs');
  const v = el ? parseFloat(el.value) : 80;
  return Number.isFinite(v) && v >= 0 ? v : 80;
}

const Crr = 0.015;
const CdA = 0.35;
const rho_air = 1.225;
const g_mps2 = 9.80665;
const LB_TO_KG = 0.45359237;
const LBF_FT_TO_NM = 1.3558179483;
const IN_TO_M = 0.0254;
const MPH_TO_MPS = 0.44704;
const MPS_TO_MPH = 2.236936;
const M_TO_FT = 3.28084;

// Vertical label placement for Accel compare markers
const ACCEL_LABEL_BASE = 0.97;
const ACCEL_LABEL_STEP = 0.03;
const ACCEL_SPEED_YMAX = 150;  // mph axis cap for accel_ts


const wheel_radius_m = (tire_circ_in * IN_TO_M) / (2 * Math.PI);

function speedToRpm(speed_mph, gear_ratio, final_drive) {
  return speed_mph * (primary_drive * gear_ratio * final_drive * 1056) / tire_circ_in;
}
function rpmToSpeed(rpm, gear_ratio, final_drive) {
  return rpm * tire_circ_in / (primary_drive * gear_ratio * final_drive * 1056);
}
function hpToWheelTorqueAt(rpmArr, hpArr, gear_ratio, final_drive) {
  const overall = primary_drive * gear_ratio * final_drive;
  return rpmArr.map((rpm, i) => (hpArr[i] * 5252 / rpm) * overall);
}
function lerp(x1, y1, x2, y2, y) { return x1 + (y - y1) * (x2 - x1) / (y2 - y1); }
function interp1(xArr, yArr, x) {
  if (x <= xArr[0]) return yArr[0];
  if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
  let lo = 0, hi = xArr.length - 1;
  while (hi - lo > 1) { const mid = (lo + hi) >> 1; if (xArr[mid] <= x) lo = mid; else hi = mid; }
  const x1 = xArr[lo], x2 = xArr[hi], y1 = yArr[lo], y2 = yArr[hi];
  return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
}

// Dense RPM array
const hp_data_sets = {
  Stock: [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    11.85,12.4,13.23,13.92,14.88,15.43,15.98,16.26,16.67,17.22,17.91,18.74,19.15,19.7,19.98,19.98,20.26,20.81,21.77,22.6,23.01,23.43,24.11,24.8,25.49,25.77,26.18,26.73,27.01,27.28,27.83,28.25,28.66,29.07,29.63,29.76,29.9,30.04,30.45,31.0,31.56,32.24,32.8,33.21,33.9,34.45,34.86,35.69,36.24,36.93,37.2,37.62,38.44,39.27,40.24,41.06,42.03,42.44,43.13,43.82,44.23,44.51,44.92,45.61,46.3,47.13,47.81,48.37,48.92,49.74,50.71,51.54,52.36,53.05,53.74,54.57,55.26,55.81,56.22,56.77,57.05,57.32,57.46,57.6,57.05,56.36,56.08,56.22,56.36,56.08,55.94,55.53,55.53,55.26,54.43,54.02,53.74,53.74,53.74,53.74,53.6,53.19,53.05,53.05,52.91,52.78,52.64,52.64,52.5,52.5,52.22,52.09,51.81,51.26,50.85,50.43,49.88,49.47,48.92,48.37,47.95,47.54,47.13,46.44,45.61,44.78,44.37
  ][i]]),
  Tuned: [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    12.93,13.75,14.72,15.27,15.82,16.23,16.64,17.05,17.47,17.74,18.15,18.43,18.7,19.12,19.53,20.22,20.9,21.18,21.73,22.14,22.69,23.1,23.79,24.07,24.2,24.89,25.58,26.4,26.68,27.09,27.64,28.06,28.47,29.02,29.43,29.98,30.53,31.08,31.77,32.32,33.01,33.56,34.24,35.07,35.62,36.17,36.58,37.27,37.68,38.37,39.06,39.61,40.02,40.57,41.26,42.08,42.91,44.28,45.11,45.93,46.48,47.03,47.45,47.86,48.13,48.68,49.23,50.06,50.88,51.43,52.12,53.08,53.91,54.73,55.7,56.39,57.07,57.62,58.04,58.86,59.96,60.24,60.37,60.65,61.2,61.34,61.61,62.02,62.71,63.26,63.67,64.22,64.77,65.6,65.87,66.01,66.84,67.39,67.94,68.49,68.62,69.17,69.72,70.55,71.1,71.24,71.38,71.38,71.51,71.51,71.24,70.83,70.41,70.14,69.59,69.04,68.21,67.11,66.42,65.74,65.05,64.22,63.4,62.44,61.47,60.51,59.55
  ][i]]),
  "Graves Full Exh": [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    12.88,13.31,13.74,14.31,15.17,15.6,16.03,16.6,17.46,17.89,18.32,18.89,19.46,19.89,20.32,20.89,21.61,22.18,22.75,23.33,23.9,24.47,24.9,25.33,25.62,25.9,26.48,27.05,27.33,27.76,28.34,28.91,29.48,30.05,30.48,30.77,31.48,31.63,32.06,32.63,33.35,33.77,34.35,34.92,35.78,36.64,37.07,37.64,38.21,39.07,39.64,40.07,40.79,42.79,44.65,45.8,46.94,48.37,48.8,48.94,49.09,49.37,49.66,50.23,50.66,51.23,51.81,52.67,53.52,54.24,54.96,56.1,56.96,57.82,59.25,59.82,60.68,61.68,62.54,62.54,63.26,63.54,63.97,64.26,64.54,64.83,64.83,64.97,65.69,65.97,66.69,67.12,67.69,68.26,69.12,69.84,70.41,70.98,71.84,72.7,72.84,73.27,74.13,74.42,74.42,74.42,74.42,74.42,74.7,74.85,74.85,74.42,73.99,73.85,73.56,73.13,72.7,71.99,71.41,70.7,70.27,69.27,68.84,68.12,67.26,65.97,65.55
  ][i]]),
  "M4 Full Exh": [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    13.3,13.8,14.18,14.47,15.04,15.32,15.74,16.17,16.6,17.02,17.87,18.44,19.15,19.86,20.57,21.28,21.7,21.99,22.41,22.84,23.55,24.4,25.11,25.96,26.67,27.23,27.94,28.65,29.22,29.93,30.35,30.92,31.63,32.34,33.05,33.48,33.9,34.33,34.75,35.18,35.6,36.03,36.6,37.16,37.59,37.73,38.3,38.87,39.43,40.0,40.43,41.7,42.84,44.11,45.39,46.67,47.94,48.94,49.5,49.93,50.35,50.78,50.92,51.35,52.06,52.48,53.05,53.33,53.76,54.75,56.03,56.74,57.73,58.58,59.57,60.43,60.99,62.27,62.84,63.55,63.97,64.4,64.96,65.11,65.53,65.96,66.52,66.95,67.23,67.66,68.09,68.79,69.36,70.07,70.64,71.21,71.77,72.34,72.91,73.76,74.18,74.75,75.32,75.74,76.31,76.6,76.74,76.74,76.74,76.74,76.74,76.45,76.17,76.03,75.46,75.04,74.61,74.33,73.62,73.05,72.62,72.06,71.63,70.78,70.21,69.22,68.09,67.94
  ][i]]),
  "Lo-Mnt/Stacks": [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    12.37,13.07,13.49,14.18,15.3,16.0,16.27,16.83,17.53,18.09,18.65,19.34,19.9,20.46,21.02,21.57,21.99,22.41,22.83,23.39,23.94,24.5,25.06,25.62,25.62,26.73,27.15,27.43,27.99,28.41,29.1,29.52,29.94,30.5,31.06,31.47,32.03,32.45,33.01,33.43,33.98,34.54,35.24,36.08,36.77,37.33,38.03,38.45,39.0,39.42,39.7,40.82,41.65,42.35,43.47,44.58,45.56,46.81,47.93,49.04,50.16,51.0,51.69,52.53,53.23,53.92,54.34,55.04,55.74,56.57,57.27,58.11,58.8,59.5,60.34,60.9,61.31,61.73,62.01,62.57,62.99,63.55,63.96,64.24,64.8,65.36,65.78,66.2,66.61,67.17,67.73,68.43,69.12,69.54,70.38,71.08,71.77,72.47,73.31,73.86,74.42,74.98,75.4,75.82,76.1,76.37,76.51,76.93,76.93,77.07,77.07,77.07,77.07,76.65,76.37,76.1,75.96,75.54,75.26,74.84,74.7,74.42,74.14,74.0,73.45,73.31,73.03
  ][i]])
};

const gear_colors = ['#FF0000', '#00FFFF', '#00FF00', '#FFFF00', '#F012BE', '#FFFFFF'];
const freezeDashStyles = ['dot', 'dash', 'longdash', 'dashdot', 'solid'];
let freezeCount = 0;
let frozenConfigurations = []; // Store configurations instead of traces
let frozenTraces = [];
let frozenConnectorTraces = [];
let previousTraces = [];
let maxX = 0, maxY = 0;
let lastFamily = null;

const densePoints = 750;
const rpm_data_raw = hp_data_sets[Object.keys(hp_data_sets)[0]].map(([r, _]) => r);
const rpmDense = (() => {
  const arr = [];
  const minR = rpm_data_raw[0];
  const maxR = rpm_data_raw[rpm_data_raw.length - 1];
  for (let i = 0; i <= densePoints; i++) arr.push(minR + (maxR - minR) * (i / densePoints));
  return arr;
})();
const hpDenseSets = {};
for (const key in hp_data_sets) {
  const rpmArrRaw = hp_data_sets[key].map(([r, hp]) => r);
  const hpArrRaw = hp_data_sets[key].map(([r, hp]) => hp);
  hpDenseSets[key] = rpmDense.map(r => interp1(rpmArrRaw, hpArrRaw, r));
}

// Utility
function viewFamily(v) { return v === 'wheel' ? 'wheel' : (v === 'dyno' ? 'dyno' : (v.startsWith('accel') ? 'accel' : v)); }

// Generate frozen traces from stored configurations for current view
function regenerateFrozenTraces() {
  frozenTraces = [];
  frozenConnectorTraces = [];
  
  const currentView = document.getElementById('viewSelect').value;
  const currentFamily = viewFamily(currentView);
  
  frozenConfigurations.forEach((config, configIndex) => {
    const dashStyle = (currentFamily === 'wheel') ? freezeDashStyles[configIndex % freezeDashStyles.length] : 'solid';
    const { front, rear, hpKey, weightLb, shiftMs, shiftRpmSetting } = config;
    const fd = rear / front;
    const rpmArr = rpmDense;
    const hpArr = hpDenseSets[hpKey];
    
    // Add spacer for legend grouping
    frozenTraces.push({ x:[null], y:[null], mode:'lines', name:'\u00A0', showlegend:true, hoverinfo:'skip', line:{color:'rgba(0,0,0,0)', width:0} });
    
    if (currentFamily === 'dyno') {
      const hpArrRaw = hp_data_sets[hpKey].map(([r, hp]) => hp);
      const rpmArrRaw = hp_data_sets[hpKey].map(([r, hp]) => r);
      const engTq = hp_data_sets[hpKey].map(([rpm, hp]) => (hp * 5252) / rpm);
      
      // Convert to user's preferred units
      const hpConverted = hpArrRaw.map(hp => UnitConverter.convertPower(hp, userPreferences.power));
      const tqConverted = engTq.map(tq => UnitConverter.convertTorque(tq, userPreferences.torque));
      
      const lineColor = gear_colors[configIndex % gear_colors.length];
      frozenTraces.push({ x:rpmArrRaw, y:tqConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line:{ color: lineColor, shape:'spline', width:2 }, opacity:0.7 });
      frozenTraces.push({ x:rpmArrRaw, y:hpConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Power: %{y:.1f} ${userPreferences.power}<extra></extra>`, line:{ color: lineColor, shape:'spline', width:2 }, opacity:0.7 });
      const maxHP = Math.max(...hpConverted), maxTQ = Math.max(...tqConverted);
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:hpKey, showlegend:true, hoverinfo:'skip', line:{ color:'rgba(0,0,0,0)', width:0 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.power}: ${maxHP.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:2 } });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.torque}: ${maxTQ.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:lineColor, shape:'spline', width:2 } });
    }
    else if (currentFamily === 'accel') {
      const sim = simulateAccel(hpArr, rpmArr, fd, 0.02, weightLb, shiftMs, shiftRpmSetting);
      let xData, yData, showShift = false;
      
      // Convert speed data to user's preferred units  
      const speedConverted = sim.V.map(mph => UnitConverter.convertSpeed(mph, userPreferences.speed));
      
      // Convert distance data based on speed unit preference
      const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
      const distanceConverted = sim.S.map(ft => UnitConverter.convertDistance(ft, distanceUnit));
      
      if (currentView === 'accel_ts') { xData = sim.T; yData = speedConverted; showShift = true; }
      else if (currentView === 'accel_td') { xData = sim.T; yData = distanceConverted; }
      else if (currentView === 'accel_tg') { xData = sim.T; yData = sim.A.map(a=>a/g_mps2); }
      else if (currentView === 'accel_sg') { xData = speedConverted; yData = sim.A.map(a=>a/g_mps2); }
      else { xData = sim.T; yData = speedConverted; }
      
      const lineColor = gear_colors[configIndex % gear_colors.length];
      const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
      const displayWeight = UnitConverter.convertWeight(weightLb, weightUnit);
      
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Weight: ${Math.round(displayWeight)} ${weightUnit}`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`Shift Time: ${shiftMs} ms`, showlegend:true, hoverinfo:'skip', line:{color:lineColor, width:2, shape:'spline'} });
      // Create proper hover template for frozen traces
      let hoverTemplate;
      if (currentView === 'accel_ts') {
        hoverTemplate = `Time: %{x:.2f}s<br>Speed: %{y:.1f} ${userPreferences.speed}<extra></extra>`;
      } else if (currentView === 'accel_td') {
        const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
        hoverTemplate = `Time: %{x:.2f}s<br>Distance: %{y:.0f} ${distanceUnit}<extra></extra>`;
      } else if (currentView === 'accel_tg') {
        hoverTemplate = `Time: %{x:.2f}s<br>Accel: %{y:.2f} g<extra></extra>`;
      } else if (currentView === 'accel_sg') {
        hoverTemplate = `Speed: %{x:.1f} ${userPreferences.speed}<br>Accel: %{y:.2f} g<extra></extra>`;
      } else {
        hoverTemplate = `Time: %{x:.2f}s<br>Speed: %{y:.1f} ${userPreferences.speed}<extra></extra>`;
      }
      
      frozenTraces.push({ x:xData, y:yData, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate: hoverTemplate, line:{ color: lineColor, width:2, shape:'spline' }, opacity:0.7 });
      
      if (showShift) {
        sim.shiftMarkers.forEach(m => {
          const yLabelPos = Math.max(0, (ACCEL_LABEL_BASE - configIndex * ACCEL_LABEL_STEP) * ACCEL_SPEED_YMAX);
          // ---- Vertical lines disabled for frozen traces ----
          //frozenConnectorTraces.push({ x:[m.t, m.t], y:[yLabelPos, m.v_mph], mode:'lines', line:{ color: gear_colors[m.gear-1], width:1 }, showlegend:false, hoverinfo:'skip', yaxis:'y' });
          //frozenConnectorTraces.push({ x:[m.t], y:[yLabelPos], mode:'text', text:[`${m.t.toFixed(2)} s`], textposition:'top center', textfont:{ color: gear_colors[m.gear-1] }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
          // ---------------------------------------------------
        });
      }
    }
    else if (currentFamily === 'wheel') {
      const { wt, shift_speed, shift_rpm } = computeShiftPoints(hpArr, fd, rpmArr, shiftRpmSetting);
      const truncate = document.getElementById("truncateCross").checked;
      frozenTraces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{ color: gear_colors[0], width: 2, dash: dashStyle, shape: 'spline' } });
      
      // Add gear traces (applying clip lines setting)
      for (let g = 1; g <= 6; g++) {
        const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
        const torques = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);
        let xPts = [], yPts = [], rpmPts = [];
        for (let i = 0; i < rpmArr.length; i++) {
          const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
          const inRange = !truncate || ((g > 1 ? sp >= shift_speed[g-1] : true) && (g < 6 ? sp <= shift_speed[g] : true));
          if (inRange) { 
            xPts.push(UnitConverter.convertSpeed(sp, userPreferences.speed)); 
            yPts.push(UnitConverter.convertTorque(tq, userPreferences.torque));
            rpmPts.push(rp);
          }
        }
        if (xPts.length) {
          let label = `Gear ${g}`;
          if (g < 6 && shift_rpm[g] != null) {
            const convertedShiftSpeed = UnitConverter.convertSpeed(shift_speed[g], userPreferences.speed);
            label += ` (${Math.round(shift_rpm[g])} RPM / ${convertedShiftSpeed.toFixed(1)} ${userPreferences.speed})`;
          }
          else if (g === 6) { 
            const red = rpmArr[rpmArr.length - 1]; 
            const sp = rpmToSpeed(red, gear_ratios[g], fd);
            const convertedSp = UnitConverter.convertSpeed(sp, userPreferences.speed);
            label += ` (${Math.round(red)} RPM / ${convertedSp.toFixed(1)} ${userPreferences.speed})`; 
          }
          frozenTraces.push({ x: xPts, y: yPts, customdata: rpmPts, mode: 'lines', name: label, showlegend: true, hovertemplate: `Speed: %{x:.1f} ${userPreferences.speed}<br>RPM: %{customdata:.0f} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line: { color: gear_colors[g-1], dash: dashStyle, width: 2, shape: 'spline', opacity: 0.3 } });
        }
      }
      
      // Add shift point connectors
      const maxYConverted = UnitConverter.convertTorque(maxY, userPreferences.torque);
      for (let g = 1; g <= 5; g++) {
        const xShift = shift_speed[g];
        if (xShift != null) {
          const yLabel = Math.max(0, (0.97 - configIndex * 0.03)) * maxYConverted;
          const speedsNext = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g + 1], fd));
          const idxNext = speedsNext.findIndex(s => s >= xShift);
          const torqueNext = idxNext !== -1 ? UnitConverter.convertTorque(wt[g + 1][idxNext], userPreferences.torque) : 0;
          const xShiftConverted = UnitConverter.convertSpeed(xShift, userPreferences.speed);
          frozenConnectorTraces.push({
            x: [xShiftConverted, xShiftConverted], y: [yLabel, torqueNext], mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: dashStyle },
            showlegend: false, hoverinfo: 'skip'
          });
          frozenConnectorTraces.push({
            x: [xShiftConverted], y: [yLabel], mode: 'text', text: [`${xShiftConverted.toFixed(1)} ${userPreferences.speed}`],
            textposition: 'top center', textfont: { color: gear_colors[g - 1] },
            showlegend: false, hoverinfo: 'skip', cliponaxis: false
          });
        }
      }
    }
  });
}
function toggleControlVisibility() {
  const view = document.getElementById('viewSelect').value;
  const accel = view.startsWith('accel');
  ['weightLbLabel','weightLb','shiftMsLabel','shiftMs'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = accel ? 'inline-block' : 'none';
  });
  const clipEl = document.getElementById('clipControl');
  if (clipEl) clipEl.style.display = (view === 'wheel') ? 'inline-block' : 'none';
  
  // Adjust layout after visibility changes
  setTimeout(() => adjustLayout(), 50);
}

// Shift points calc - with optional shift RPM override
function computeShiftPoints(hpArr, final_drive, rpmArr, shiftRpmOverride = null) {
  const wt = {}, spd = {};
  for (let g = 1; g <= 6; g++) {
    wt[g]  = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], final_drive);
    spd[g] = rpmArr.map(rpm => rpmToSpeed(rpm, gear_ratios[g], final_drive));
  }
  
  const shiftRpmSetting = shiftRpmOverride || (document.getElementById('shiftRpmSelect')?.value) || 'optimal';
  const shift_rpm = {}, shift_speed = {};
  
  for (let g = 1; g <= 5; g++) {
    let shiftRPM;
    
    if (shiftRpmSetting === 'optimal') {
      // Original optimal shift point calculation
      const ratio  = gear_ratios[g + 1] / gear_ratios[g];
      const diff   = [];
      for (let i = 0; i < rpmArr.length; i++) {
        const rp    = rpmArr[i];
        const curTq = wt[g][i];
        const nxtTq = interp1(rpmArr, wt[g + 1], rp * ratio);
        diff.push(nxtTq - curTq);
      }
      let idx = diff.findIndex(d => d >= 0);
      if (idx === -1) shiftRPM = rpmArr[rpmArr.length - 1];
      else if (idx === 0) shiftRPM = rpmArr[0];
      else shiftRPM = lerp(rpmArr[idx - 1], diff[idx - 1], rpmArr[idx], diff[idx], 0);
    } else {
      // Use fixed RPM from dropdown
      shiftRPM = parseFloat(shiftRpmSetting);
      // Clamp to valid RPM range
      shiftRPM = Math.max(rpmArr[0], Math.min(rpmArr[rpmArr.length - 1], shiftRPM));
    }
    
    shift_rpm[g]   = shiftRPM;
    shift_speed[g] = rpmToSpeed(shiftRPM, gear_ratios[g], final_drive);
  }
  return { wt, spd, shift_rpm, shift_speed };
}

// Accel sim with trapezoidal distance and shift time
function simulateAccel(hpArr, rpmArr, final_drive, dt = 0.02, mass_lb_param = getMassLb(), shift_ms = getShiftMs(), shiftRpmOverride = null) {
  function wheelTorqueAtSpeed(speed_mps, gear) {
    const speed_mph = speed_mps * MPS_TO_MPH;
    const rpm = Math.max(rpmArr[0], Math.min(rpmArr[rpmArr.length - 1], speedToRpm(speed_mph, gear_ratios[gear], final_drive)));
    const hp = interp1(rpmArr, hpArr, rpm);
    const tq_lbft = (hp * 5252) / rpm;
    const overall = primary_drive * gear_ratios[gear] * final_drive;
    const tq_wheel_Nm = tq_lbft * overall * LBF_FT_TO_NM;
    return tq_wheel_Nm / wheel_radius_m;
  }

  const mass_kg = mass_lb_param * LB_TO_KG;
  const max_rpm = rpmArr[rpmArr.length - 1];
  const { shift_speed } = computeShiftPoints(hpArr, final_drive, rpmArr, shiftRpmOverride);

  let g = 1, t = 0, v = 0, s = 0;
  let shiftCooldown = 0, pendingGear = null;
  const cooldownSteps = Math.max(0, Math.round((shift_ms / 1000) / dt));

  const T = [0], V = [0], A = [0], S = [0], G = [g], shiftMarkers = [];

  for (let step = 0; step < 20000; step++) {
    if (shiftCooldown === 0 && pendingGear === null && g <= 5) {
      const v_shift_mph = shift_speed[g];
      if (v_shift_mph !== undefined && v * MPS_TO_MPH >= v_shift_mph) {
        shiftMarkers.push({ t, v_mph: v * MPS_TO_MPH, gear: g });
        pendingGear = g + 1;
        shiftCooldown = cooldownSteps;
      }
    }

    let F_trac;
    if (shiftCooldown > 0) {
      F_trac = 0;
      shiftCooldown -= 1;
      if (shiftCooldown === 0 && pendingGear !== null) {
        g = pendingGear;
        pendingGear = null;
      }
    } else {
      F_trac = wheelTorqueAtSpeed(v, g);
    }

    const rpm_now = speedToRpm(v * MPS_TO_MPH, gear_ratios[g], final_drive);
    if (g === 6 && rpm_now >= max_rpm) break;

    const F_roll = Crr * mass_kg * g_mps2;
    const F_aero = 0.5 * rho_air * CdA * v * v;
    const F_net = Math.max(0, F_trac - F_roll - F_aero);
    const a = F_net / mass_kg;

    // Trapezoid integration for distance over this step
    s += v * dt + 0.5 * a * dt * dt;
    v += a * dt;
    t += dt;

    T.push(t);
    V.push(v * MPS_TO_MPH);
    A.push(a);
    S.push(s * M_TO_FT);
    G.push(g);

    if (a < 0.05 && v > 60 * MPH_TO_MPS) {
      if (T.length > 200 && Math.abs(V[V.length - 1] - V[V.length - 200]) < 0.5) break;
    }
  }
  return { T, V, A, S, G, shiftMarkers };
}

// Precompute dyno y max
const dynoMaxHP = (() => {
  let maxVal = 0;
  Object.values(hp_data_sets).forEach(arr => arr.forEach(([rpm, v]) => { if (v > maxVal) maxVal = v; }));
  return Math.ceil(maxVal / 10) * 10;
})();

function populateHpDropdown() {
  const sel = document.getElementById('hpData');
  sel.innerHTML = '';
  const keys = Object.keys(hp_data_sets);
  keys.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  if (keys.includes('Stock')) sel.value = 'Stock'; else if (keys.length) sel.value = keys[0];
}

function populateShiftRpmDropdown() {
  const sel = document.getElementById('shiftRpmSelect');
  sel.innerHTML = '';
  
  // Add 'Optimal' as first option
  const optimalOpt = document.createElement('option');
  optimalOpt.value = 'optimal'; optimalOpt.textContent = 'Optimal'; sel.appendChild(optimalOpt);
  
  // Get all distinct RPM values from hp_data_sets
  const rpmSet = new Set();
  Object.values(hp_data_sets).forEach(dataArray => {
    dataArray.forEach(([rpm, hp]) => {
      rpmSet.add(rpm);
    });
  });
  
  // Convert to sorted array (descending)
  const distinctRpms = Array.from(rpmSet).sort((a, b) => b - a);
  
  // Add RPM options
  distinctRpms.forEach(rpm => {
    const opt = document.createElement('option');
    opt.value = rpm; opt.textContent = `${rpm} RPM`; sel.appendChild(opt);
  });
  
  // Set default to 'Optimal'
  sel.value = 'optimal';
}

function getPlotBounds() {
  const all_hp = Object.values(hp_data_sets);
  const fd_ratios = [48/13, 48/14, 50/13, 50/14];
  for (const gr of Object.values(gear_ratios)) {
    for (const hpArr of all_hp) {
      const rpmArrRaw = hpArr.map(([r, hp]) => r);
      const hpArrRaw = hpArr.map(([r, hp]) => hp);
      for (const fd of fd_ratios) {
        for (let i = 0; i < rpmArrRaw.length; i++) {
          const rpm = rpmArrRaw[i], hp = hpArrRaw[i];
          const speed = rpmToSpeed(rpm, gr, fd);
          const tq    = (hp * 5252 / rpm) * (primary_drive * gr * fd);
          if (speed > maxX) maxX = speed;
          if (tq    > maxY) maxY = tq;
        }
      }
    }
  }
  maxY = Math.ceil(maxY / 100) * 100;
}

function freezeCurrentTraces() {
  // Store current configuration instead of generating traces
  const front = parseInt(document.getElementById('front').value);
  const rear = parseInt(document.getElementById('rear').value);
  const hpKey = document.getElementById('hpData').value;
  const weightLb = getMassLb();
  const shiftMs = getShiftMs();
  const shiftRpmSetting = document.getElementById('shiftRpmSelect').value;
  
  // Add configuration to frozen configurations array
  frozenConfigurations.push({ front, rear, hpKey, weightLb, shiftMs, shiftRpmSetting });
  freezeCount++;
  
  // Regenerate all frozen traces for current view
  regenerateFrozenTraces();
  
  const notif = document.getElementById('freezeNotification');
  notif.style.display = 'block'; setTimeout(()=>{ notif.style.display='none'; }, 2000);
  plotTorque(false); // <--- This line redraws the plot after freezing traces
}
function clearFrozenTraces() {
  document.getElementById("front").value = "14";
  document.getElementById("rear").value = "48";
  document.getElementById("hpData").value = "Stock";
  document.getElementById("shiftRpmSelect").value = "optimal";
  document.getElementById("truncateCross").checked = false;
  frozenConfigurations = []; frozenTraces = []; freezeCount = 0; frozenConnectorTraces = [];
  plotTorque();
}

function plotTorque(animate = true) {
  const view = document.getElementById('viewSelect').value;
  const fam = viewFamily(view);
  toggleControlVisibility();

  // Remember the last view for comparison
  const lastView = window.lastPlotView;
  window.lastPlotView = view;
  
  // Regenerate frozen traces when view changes (only if we have configurations)
  if ((lastFamily !== null && fam !== lastFamily) || (lastView && lastView !== view)) {
    if (frozenConfigurations.length > 0) {
      regenerateFrozenTraces();
    }
  }
  lastFamily = fam;
  
  // Also regenerate if we have configurations but no traces (initial load)
  if (frozenConfigurations.length > 0 && frozenTraces.length === 0) {
    regenerateFrozenTraces();
  }
  
  // Always regenerate frozen traces if we have configurations (to respect current settings)
  if (frozenConfigurations.length > 0) {
    regenerateFrozenTraces();
  }

  const front = parseInt(document.getElementById("front").value);
  const rear  = parseInt(document.getElementById("rear").value);
  const hpKey = document.getElementById("hpData").value;
  const rpmArr = rpmDense;
  const hpArr  = hpDenseSets[hpKey];
  const fd = rear / front;
  const activeDash = (fam === 'wheel' && freezeCount > 1 && animate) ? freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length] : null;

  if (view === 'dyno') {
    const hpArrRaw = hp_data_sets[hpKey].map(([r, hp]) => hp);
    const rpmArrRaw = hp_data_sets[hpKey].map(([r, hp]) => r);
    const engTq = hp_data_sets[hpKey].map(([rpm, hp]) => (hp * 5252) / rpm);
    
    // Convert to user's preferred units
    const hpConverted = hpArrRaw.map(hp => UnitConverter.convertPower(hp, userPreferences.power));
    const tqConverted = engTq.map(tq => UnitConverter.convertTorque(tq, userPreferences.torque));
    
    const currentColor = gear_colors[freezeCount % gear_colors.length];
    const dynoTraces = [
      { x: rpmArrRaw, y: tqConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>`, line:{ color: currentColor, shape:'spline', width:2 } },
      { x: rpmArrRaw, y: hpConverted, mode:'lines', showlegend:false, hoverinfo:'x+y', hovertemplate:`RPM: %{x} RPM<br>Power: %{y:.1f} ${userPreferences.power}<extra></extra>`, line:{ color: currentColor, shape:'spline', width:2 } }
    ];
    const maxHP = Math.max(...hpConverted), maxTQ = Math.max(...tqConverted);
    const legendTraces = [
      { x:[null], y:[null], mode:'lines', name:hpKey, showlegend:true, hoverinfo:'skip', line:{ color:'rgba(0,0,0,0)', width:0 } },
      { x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.power}: ${maxHP.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:2 } },
      { x:[null], y:[null], mode:'lines', name:`Max ${userPreferences.torque}: ${maxTQ.toFixed(1)}`, showlegend:true, hoverinfo:'skip', line:{ color:currentColor, shape:'spline', width:2 } }
    ];
    const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
    const dynoYMax = Math.ceil(Math.max(maxHP, maxTQ) * 1.1 / 10) * 10;
    const dynoLayout = { title: viewTitle, xaxis:{ title:'RPM', color:'white', autorange:false, range:[rpmArrRaw[0], rpmArrRaw[rpmArrRaw.length-1] + 2000] }, yaxis:{ title:`${UnitConverter.getPowerLabel(userPreferences.power)} / ${UnitConverter.getTorqueLabel(userPreferences.torque)}`, color:'white', autorange:false, range:[0, dynoYMax] }, plot_bgcolor:'#111', paper_bgcolor:'#111', font:{ color:'white' }, transition:{ duration:1000, easing:'cubic-in-out' }, hovermode:'closest', hoverdistance:10 };
    const allDynoTraces = [...dynoTraces, ...legendTraces, ...frozenTraces];
    if (animate) Plotly.react('plot', allDynoTraces, dynoLayout, {responsive:true});
    else { const staticLayout = { ...dynoLayout }; delete staticLayout.transition; Plotly.newPlot('plot', allDynoTraces, staticLayout, {responsive:true}); }
    Plotly.Plots.resize(document.getElementById('plot'));
    previousTraces = []; return;
  }

  if (fam === 'accel') {
    const sim = simulateAccel(hpArr, rpmArr, fd, 0.02);
    let xData, yData, xTitle, yTitle, lockX=false, lockY=false, showShift=false;
    
    // Convert speed data to user's preferred units
    const speedConverted = sim.V.map(mph => UnitConverter.convertSpeed(mph, userPreferences.speed));
    const speedMax = Math.ceil(Math.max(...speedConverted) * 1.1 / 10) * 10;
    
    // Convert distance data based on speed unit preference
    const distanceUnit = UnitConverter.getDistanceUnit(userPreferences.speed);
    const distanceConverted = sim.S.map(ft => UnitConverter.convertDistance(ft, distanceUnit));
    
    if (view === 'accel_ts') { 
      xData = sim.T; 
      yData = speedConverted; 
      xTitle='Time (s)'; 
      yTitle=UnitConverter.getSpeedLabel(userPreferences.speed); 
      lockX=true; lockY=true; showShift=true; 
    }
    else if (view === 'accel_td') { 
      xData = sim.T; 
      yData = distanceConverted; 
      xTitle='Time (s)'; 
      yTitle=UnitConverter.getDistanceLabel(distanceUnit); 
    }
    else if (view === 'accel_tg') { xData = sim.T; yData = sim.A.map(a=>a/g_mps2); xTitle='Time (s)'; yTitle='Acceleration (g)'; }
    else if (view === 'accel_sg') { 
      xData = speedConverted; 
      yData = sim.A.map(a=>a/g_mps2); 
      xTitle=UnitConverter.getSpeedLabel(userPreferences.speed); 
      yTitle='Acceleration (g)'; 
    }
    else { xData = sim.T; yData = speedConverted; xTitle='Time (s)'; yTitle=UnitConverter.getSpeedLabel(userPreferences.speed); }

    const traces = [];
    const currentColor = gear_colors[freezeCount % gear_colors.length];
    const weightLb = getMassLb();
    const shiftMs = getShiftMs();
    
    // Add legend entries with configuration details
    const weightUnit = UnitConverter.getWeightUnit(userPreferences.speed);
    const displayWeight = UnitConverter.convertWeight(weightLb, weightUnit);
    
    traces.push({ x:[null], y:[null], mode:'lines', name:`(F${front}/R${rear} ${hpKey})`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    traces.push({ x:[null], y:[null], mode:'lines', name:`Weight: ${Math.round(displayWeight)} ${weightUnit}`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    traces.push({ x:[null], y:[null], mode:'lines', name:`Shift Time: ${shiftMs} ms`, showlegend:true, hoverinfo:'skip', line:{ color: currentColor, width:2, shape:'spline' } });
    traces.push({ x:xData, y:yData, mode:'lines', name:'Acceleration View', showlegend:false, hoverinfo:'x+y',
      hovertemplate: (xTitle.startsWith('Time') ? `Time: %{x:.2f}s` : `Speed: %{x:.1f} ${userPreferences.speed}`) + '<br>' +
        (yTitle.includes('Speed') ? `Speed: %{y:.1f} ${userPreferences.speed}` : 
         yTitle.includes('Distance') ? `Distance: %{y:.0f} ${yTitle.includes('(m)') ? 'm' : 'ft'}` : 
         `Accel: %{y:.2f} g`) +
        '<extra></extra>',
      line:{ color: currentColor, width:2, shape:'spline' } });

    const connectorTraces = [];
    if (showShift) {
      sim.shiftMarkers.forEach(m => {
        const yLabelPos = Math.max(0, (ACCEL_LABEL_BASE - freezeCount * ACCEL_LABEL_STEP) * ACCEL_SPEED_YMAX);
        const shiftColor = gear_colors[Math.max(0, m.gear-1)];
        // ---- These two lines draw the vertical lines and labels ----
        //connectorTraces.push({ x:[m.t, m.t], y:[yLabelPos, m.v_mph], mode:'lines', line:{ color: shiftColor, width:2 }, showlegend:false, hoverinfo:'skip' });
        //connectorTraces.push({ x:[m.t], y:[yLabelPos], mode:'text', text:[`${m.t.toFixed(2)} s`], textposition:'top center', textfont:{ color: shiftColor }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
        // -----------------------------------------------------------
      });
    }

    const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
    const layout = {
      title: viewTitle,
      xaxis: lockX ? { title:xTitle, color:'white', range:[0,30] } : { title:xTitle, color:'white' },
      yaxis: lockY ? { title:yTitle, color:'white', range:[0,speedMax || 150] } : { title:yTitle, color:'white' },
      plot_bgcolor:'#111', paper_bgcolor:'#111', font:{ color:'white' },
      hovermode:'closest', hoverdistance:10, transition:{ duration:1000, easing:'cubic-in-out' }
    };

    const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
    if (animate) Plotly.react('plot', allTraces, layout, { responsive:true });
    else { const staticLayout = { ...layout }; delete staticLayout.transition; Plotly.newPlot('plot', allTraces, staticLayout, { responsive:true }); }
    previousTraces = [...traces, ...connectorTraces];
    Plotly.Plots.resize(document.getElementById('plot'));
    return;
  }

  // Wheel TQ
  const { wt, spd, shift_rpm, shift_speed } = computeShiftPoints(hpArr, fd, rpmArr);
  const truncate = document.getElementById("truncateCross").checked;
  const traces = [];
  const groupLabel = `(F${front}/R${rear} ${hpKey})`;
  traces.push({ x:[null], y:[null], mode:'lines', name:groupLabel, showlegend:true, hoverinfo:'skip', line:{ color: gear_colors[0], width:2, shape:'spline' } });

  for (let g = 1; g <= 6; g++) {
    const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
    const torques = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);
    let xPts = [], yPts = [], rpmPts = [];
    for (let i = 0; i < rpmArr.length; i++) {
      const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
      const inRange = !truncate || ((g > 1 ? sp >= shift_speed[g-1] : true) && (g < 6 ? sp <= shift_speed[g] : true));
      if (inRange) { 
        xPts.push(UnitConverter.convertSpeed(sp, userPreferences.speed)); 
        yPts.push(UnitConverter.convertTorque(tq, userPreferences.torque)); 
        rpmPts.push(rp); 
      }
    }
    if (xPts.length) {
      let label = `Gear ${g}`;
      if (g < 6 && shift_rpm[g] != null) {
        const convertedShiftSpeed = UnitConverter.convertSpeed(shift_speed[g], userPreferences.speed);
        label += ` (${Math.round(shift_rpm[g])} RPM / ${convertedShiftSpeed.toFixed(1)} ${userPreferences.speed})`;
      }
      else if (g === 6) { 
        const red = rpmArr[rpmArr.length - 1]; 
        const sp = rpmToSpeed(red, gear_ratios[g], fd); 
        const convertedSp = UnitConverter.convertSpeed(sp, userPreferences.speed);
        label += ` (${Math.round(red)} RPM / ${convertedSp.toFixed(1)} ${userPreferences.speed})`; 
      }
      traces.push({ x:xPts, y:yPts, customdata:rpmPts, mode:'lines', name:label, line:{ color:gear_colors[g-1], width:2, shape:'spline' }, opacity:1, hovertemplate:`Speed: %{x:.1f} ${userPreferences.speed}<br>RPM: %{customdata:.0f} RPM<br>Torque: %{y:.1f} ${userPreferences.torque}<extra></extra>` });
    }
  }

  const connectorTraces = [];
  // Calculate converted max values for layout
  const maxXConverted = UnitConverter.convertSpeed(maxX, userPreferences.speed);
  const maxYConverted = UnitConverter.convertTorque(maxY, userPreferences.torque);
  
  for (let g = 1; g <= 5; g++) {
    const xShift = shift_speed[g];
    if (xShift != null) {
      const baseRatio = 0.97, stepRatio = 0.03;
      const yLabel = Math.max(0, baseRatio - freezeCount * stepRatio) * maxYConverted;
      const speedsNext = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g + 1], fd));
      const idxNext = speedsNext.findIndex(s => s >= xShift);
      const torqueNext = idxNext !== -1 ? UnitConverter.convertTorque(wt[g + 1][idxNext], userPreferences.torque) : 0;
      const xShiftConverted = UnitConverter.convertSpeed(xShift, userPreferences.speed);
      connectorTraces.push({ x:[xShiftConverted, xShiftConverted], y:[yLabel, torqueNext], mode:'lines', line:{ color:gear_colors[g - 1], width:2, dash: activeDash || 'solid' }, showlegend:false, hoverinfo:'skip' });
      connectorTraces.push({ x:[xShiftConverted], y:[yLabel], mode:'text', text:[`${xShiftConverted.toFixed(1)} ${userPreferences.speed}`], textposition:'top center', textfont:{ color:gear_colors[g - 1] }, showlegend:false, hoverinfo:'skip', cliponaxis:false });
    }
  }

  const viewTitle = document.getElementById('viewSelect').options[document.getElementById('viewSelect').selectedIndex].text;
  const layout = { transition:{ duration:1000, easing:'cubic-in-out' }, hovermode:'closest', hoverdistance:10, title: viewTitle, xaxis:{title:UnitConverter.getSpeedLabel(userPreferences.speed), color:'white', range:[0,maxXConverted]}, yaxis:{title:`Wheel ${UnitConverter.getTorqueLabel(userPreferences.torque)}`, color:'white', range:[0,maxYConverted]}, plot_bgcolor:'#111', paper_bgcolor:'#111', font:{color:'white'} };
  const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
  if (animate) Plotly.react('plot', allTraces, layout, {responsive: true});
  else { const staticLayout = { ...layout }; delete staticLayout.transition; Plotly.newPlot('plot', allTraces, staticLayout, {responsive: true}); }
  previousTraces = [...traces, ...connectorTraces];
  Plotly.Plots.resize(document.getElementById('plot'));
}

function adjustLayout() {
  const plot = document.getElementById('plot');
  const controls = document.querySelector('.controls');
  const buttonRow = document.querySelector('.button-row');
  const h1 = document.querySelector('h1');
  
  // Calculate available height
  const windowHeight = window.innerHeight;
  const windowWidth = window.innerWidth;
  
  // Get actual heights of elements
  const controlsHeight = controls ? controls.offsetHeight : 0;
  const buttonRowHeight = buttonRow ? buttonRow.offsetHeight : 0;
  const h1Height = h1 ? h1.offsetHeight : 0;
  
  // Calculate available space for plot (with some padding)
  const availableHeight = windowHeight - controlsHeight - buttonRowHeight - h1Height - 60; // 60px padding
  const availableWidth = windowWidth - 20; // 20px padding
  
  // Calculate ideal plot dimensions maintaining 16:9 aspect ratio
  let plotWidth = Math.min(availableWidth, availableHeight * (16/9));
  let plotHeight = plotWidth * (9/16);
  
  // If calculated height is too large, constrain by height instead
  if (plotHeight > availableHeight) {
    plotHeight = availableHeight;
    plotWidth = plotHeight * (16/9);
  }
  
  // Apply the calculated dimensions
  if (plot) {
    plot.style.width = `${plotWidth}px`;
    plot.style.height = `${plotHeight}px`;
    plot.style.maxWidth = `${plotWidth}px`;
    plot.style.maxHeight = `${plotHeight}px`;
  }
}

function init() { 
  loadUnitPreferences(); // Load saved preferences
  populateHpDropdown(); 
  populateShiftRpmDropdown(); 
  getPlotBounds(); 
  plotTorque(); 
  toggleControlVisibility(); 
  adjustLayout();
}

document.addEventListener('DOMContentLoaded', init);
window.addEventListener('resize', () => {
  adjustLayout();
  setTimeout(() => plotTorque(false), 100); // Small delay to let layout settle
});
</script>
</body>
</html>
